\chapter{Availability and Validity Verification}

\section{Introduction}

Validators are responsible for guaranteeing the validity and availability of PoV blocks. 
There are two phases of validation that takes place in the AnV protocol. 

The primary validation check is carried out by parachain validators who are assigned to the parachain which has produced the PoV block as described in Section \ref{sect-primary-validation}. Once parachain validators have validated a parachain's PoV block successfully, they have to announce according to the procedure described in Section \ref{sect-primary-validaty-announcement}.

As soon as the proposal of a PoV block is on-chain, the parachain validators break the PoV block into erasure-coded pieces as described in Section \ref{sect-erasure-code-pov} and distribute them among all validators. See Section \ref{sect-distribute-pieces} for details on how this distribution takes place.
	 
Once validators have received erasure-coded pieces for several PoV blocks for the current relay chain block (that might have been proposed a couple of blocks earlier on the relay chain), they announce that they have received the erasure coded pieces on the relay chain by voting on the received pieces, see Section \ref{sect-voting-on-availability} for more details. 

As soon as $>2/3$ of validators have made this announcement for any parachain block we act on the parachain block i.e., we update the relay chain state based on the the candidate receipt and considered the parachain block to have happened on this relay chain fork. 

After a certain time, if a candidate receipt for a parachain block is not discovered to be available we decide it is unavailable and allow alternative blocks to be built on its parent parachain block, see \ref{sect-unavailability}. 

The secondary check described in Section \ref{sect-approval-checking}, is done by one or more randomly assigned validators to make sure colluding parachain validators may not get away with validating a PoV block that is invalid and not keeping it available to avoid the possibility of being punished for the attack.
%The security analysis at the end of this document dives deeper into the incentives of the necessity of the secondary checking validity/availability checking. 

Once a parachain block is acted on we carry the secondary validity/availability checks as follows. A scheme assigns every validator to one or more PoV blocks to check its validity, see Section \ref{sect-shot-assignment} for details. An assigned validator acquires the PoV block (see Section \ref{sect-obtaining-block}) and checks its validity by comparing it to the candidate receipt. If validators notices that an equivocation has happened an additional validity/availability assignments will be made that is described in Section\ref{sect-equivocation-case}. 
During any of the phases, if any validator announces that a parachain block is invalid then all validators obtain the parachain block and check its validity, see Section \ref{sect-escalation} for more details. 

All validity and invalidity attestations go onto the relay chain, see Section \ref{sect-publishing-attestations} for details. If a parachain block has been checked at least by certain number of validators, the rest of the validators continue with voting on that relay chain block in the GRANDPA protocol. Note that the block might be challenged later. 
	 
\section{Preliminaries}

\begin{definition}
In the remainder of this chapter we assume that $\rho$ is a Polkadot Parachain and $B$ is a block which has been produced by $\rho$ and is supposed to be approved to be $\rho$'s next block. By $R_{rho}$ we refer to runtime code of parachain $\rho$  as a WASM Blob. 
\end{definition}

\begin{definition}
  \label{defn-witness-proof}
  The {\b witness proof} of block $B$, denoted by {\bf $\pi_B$}, is the set of all the external data which has gathered while the $\rho$ runtime executes block $B$. The data is suffice to re-execute $R_{rho}$ against $B$ and achieve the final state indicated in the $H(B)$.
\end{definition}

\begin{definition}
  \label{defn-pov-block}
  Accordingly we define the {\bf proof of validity block} or {\bf PoV} block in short, %{\bf $\PoVB$},
  to be the tuple:
  \[
  (B, \pi_B)
  \]
\end{definition}

\begin{definition}  \label{defn-extra-validation-data}
  {\b The extra validation data} $v_B$  is an extra input to the validation function, i.e. additional data from the relay chain state that is needed.
\end{definition}

There may be different validation data for the same $B$ as it depends on the relay chain state at the time the parachain validators attempted to get the corresponding candidate receipt into the relay chain. The validation data includes things like the previous parachain block header, likely including the previous state root.

\begin{definition}
  \label{defn-blob}
  Accordingly we define the {\bf erasure coding blob} or {\bf blob} in short, {\bf $\blobB$} to be the tuple:
  \[
  (B, \pi_B, v_B)
  \]
\end{definition}

\section{Primary Validation}
\label{sect-primary-validation}

Primary validity checking refers to the process of parachain validators as defined in Definition \ref{defn-parachain-validator} validating a parachain's PoV block as explained in Algorithm \ref{algo-primary-validation}.

\begin{algorithm}
  \caption[]{\sc PrimaryValidation}
  \label{algo-primary-validation}
  \begin{algorithmic}[1]
    \Require{$B$, $\pi_B$, relay chain parent block $B_{relay parent}$}
    %%  \Ensure{}
    
    \State Retrieve $v_B$ from the relay chain state at $B_{relay parent}$
    \State Run Algorithm \ref{algo-validate-block} usinf $B, \pi_B, v_B$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption[]{\sc ValidateBlock}
  \label{algo-validate-block}
  \begin{algorithmic}[1]
    \Require{$B, \pi_B, v_B$}
    %%  \Ensure{}
    \State retrieve the runtime code $R_\rho$ that is specified by $v_B$ from the relay chain state.
    \State check that the initial state in $\pi_B$ is the one claimed in $v_B$
    \State Execute $R_\rho$ on $B$ using $\pi_B$ to simulate the state.    
    \State If the execution fails, return fail.
    \State Else return success, the new header data $h_B$ and the outgoing messages $M$.
  \end{algorithmic}
\end{algorithm}

\subsection{Primary validity announcement}
\label{sect-primary-validaty-announcement}
Validator $v$ needs to perform Algorithm \ref{algo-primary-validation-announcement} to announce the result of primary validation to the Polkadot network.

In case that validation has been successful, the announcement will either in the form of sending the candidate receipt for block $B$ as defined in Definition \ref{defn-candidate-receipt}, to the relay chain or confirm a candidate receipt sent in from another parachain validators for this block according to Algorithm \ref{algo-endorse-candidate-receipt}
o
However, if the validation fails, $v$ reacts by executing Algorithm \ref{algo-announce-primary-validation-failure}.

\begin{definition}
  \label{defn-candidate-receipt}
        {\b TBS} is a proposal for $B$,
\end{definition}

\begin{algorithm}
  \caption[PrimaryValidationAnnouncement]{\sc PrimaryValidationAnnouncement}
  \label{algo-primary-validation-announcement}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}
    
    \State TBS
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption[]{\sc SendPoVCandidateReceipt}
  \label{algo-send-candidate-receipt}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}
    
    \State TBS
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption[]{\sc ConfirmCandidateReceipt}
  \label{algo-endorse-candidate-receipt}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}
    
    \State TBS
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption[]{\sc AnnouncePrimaryValidationFailure}
  \label{algo-announce-primary-validation-failure}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}
    
    \State
  \end{algorithmic}
\end{algorithm}

\subsection{Inclusion of candidate receipt on the relay chain}

\begin{definition}
  \label{defn-para-proposal}
        {\b Parachain Block Proposal} is a candidate receipt for a parachain block for a parachain $\rho$ along with signatures for at least 2/3 of $mathcal{V}_\rho$ 

\end{definition}

\subsection{Primary Validation Disagreement}
\label{sect-primary-validation-disagreemnt}
\syed{Parachain}{verify} validators need to keep track of candidate receipts (see Definition \ref{defn-candidate-receipt}) and validation failure messages of their peer. In case, there is a disagreement among the parachain validators about $\blobB$, all parachain validators must invoke Algorithm \ref{algo-primary-validation-disagreemnt}

\begin{algorithm}
  \caption[]{\sc PrimaryValidationDisagreement}
  \label{algo-primary-validation-disagreemnt}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}
    
    \State TBS
  \end{algorithmic}
\end{algorithm}

\section{Availability}

When a $v \in \paraValidSet$ observes that a block containing PoV Proposal is included in a relay chain block $R_p$ then it must invoke Algorithm \ref{algo-erasure-encode}.

\begin{definition}
  \label{defn-erasure-encoder-decoder}
  The {\bf erasure encoder/decoder} {\bf $encode_{k,n}/decoder_{k,n}$ } is defined to be the Reed-Solomon encoder defined in \cite{??}. 
\end{definition}

\begin{algorithm}
  \caption[]{\sc Erasure-Encode($\blobB$, $n$}
  \label{algo-erasure-encode}
  \begin{algorithmic}[1]
  \Require
    $\blobB$: blob defined in Definition \ref{defn-blob}
  
    \State TBS
  \end{algorithmic}
\end{algorithm}

\begin{definition}
  \label{defn-erasure-coded-pieces} 
  The {\bf set of erasure encode pieces} of $\blobB$, denoted by: 
  \[
   Er_B := {(e_1, m_1),...,(e_n,m_n)}
   \]
   is defined to be the output of the Algorithm \ref{algo-erasure-encode}.
\end{definition}

\section{Distribution of Pieces}\label{sect-distribute-piece}
Following the computation of $Er_B$, $v$ must construct the $\blobB$ Avalailability message defined in Definition \ref{defn-pov-erasure-piece-message}. And distribute them to target validators designated by the Availability Networking Specification \cite{??}.

\begin{definition}
  \label{defn-pov-erasure-piece-message}
        {\b PoV erasure piece message} $M_{PoV_{\blobB}}(i)$ is TBS
\end{definition}

\section{Announcing Availability}\label{sect-voting-on-availability}

When validator $v$ receives its designated piece for \blobB it needs to broadcast Availability vote message as defined in Definition\ref{defn-availability-vote-message}
\begin{definition}
  \label{defn-availability-vote-message} 
        {\b Availability vote message} $M_{PoV}^{Avail,v_i}$ TBS
\end{definition}


Some parachains have blocks that we need to vote on the availability of, that is decided by >2/3 of validators voting for availability. \syed{For 100 parachain and 1000 validators this will involve putting 100k items of data and processing them on-chain for every relay chain block, hence we want to use bit operations as follows.}{this is not really relevant to the spec}

For each parachain, we store:

\textbf{1) availability status, 2) candidate receipt, 3) candidate relay chain block no}

where availability status if one of \{no candidate, to be determined, unavailable, available\} .

For each block, each validator $v$ signs a message

Sign(bitfield $b_v$, block hash $h_b$)

where the $i$th bit of $b_v$ is $1$ if and only if 

\begin{enumerate}
\item the availability status of the candidate receipt is "to be determined" on the relay chain at block hash $h_b$ \textbf{and}

\item $v$ has the erasure coded piece of the corresponding parachain block to this candidate receipt.
\end{enumerate}

These signatures go into a relay chain block and are processed as follows:

\begin{algorithm}
  \caption[]{Relay chain's signature processing}
  \label{algo-singnature-processing} 
  \begin{algorithmic}[1]
%\begin{enumerate}
\State We store the last vote from each validator on chain. For each new signature, we check if it is for a block in this chain later than the last vote we stored from this validator. If it is we update it and store the bitfield $b_v$ and block number of the vote.
\State For each block within the last $t$ blocks where $t$ is some timeout period, we compute a bitmask $bm_n$ ($n$ is block number). This bitmask is a bitfield that represents whether the candidate considered in that block is still relevant. That is the $i$th bit of $bm_n$ is $1$ if and only if for the $i$th parachain, 
    (a) the availability status is to be determined and
    (b) candidate block number <= n   
\State We initialise a vector of counts with one entry for each parachain to zero. After executing the following algorithm we end up with a vector of counts  of the number of validators who think the latest candidates is available. 
	\begin{enumerate}
    \item We compute 
    $b_v$ and $bm_n$ 
    where $n$ is the block number of the validator's last vote
   \item For each bit in $b_v$ and $bm_n$
		\begin{itemize}
        \item add the $i$th bit to the $i$th count.
        \end{itemize}
	\end{enumerate}	
\State For each count that is $>2/3$ of the number of validators, we set the candidates status to "available". Otherwise, if the candidate is at least $t$ blocks old, then we set its status to "unavailable".
\State We act on available candidates and discard unavailable ones, and then clear the record, setting the availability status to no candidate. Then we accept new candidate receipts for these parachains, with any such new candidate receipts having their availability status as to be determined.
%\end{enumerate}
\end{algorithmic}
\end{algorithm}

\begin{definition}
  \label{defn-available-parablock-proposal}
        %{\b}
        Parachain blocks blocks for which the corresponding blob is  noted on the relay chain to be available, meaning that the candidate receipt has been voted to be available by 2/3 validators.
\end{definition}

\section{Unavailability}
\label{sect-unavailability}
After a certain time-out in blocks since we first put the candidate receipt on the relay chain if there is not enough votes of availability the relay chain logic decides that a parachain block is unavailable, see \ref{algo-singnature-processing}. 

\section{Publishing Attestations}
\label{sect-publishing-attestations}
We have two type of attestations, primary and secondary. Primary attrstations are signed buy the parachain validators and secondary attrstations are signed by secondary chechers and inlclude the vrf that assigned them as a secondary checker into the attestation. Both types of attestations are included in the relay chain block as a transaction.

\section{Approval Checker Assignment}
\label{sect-shot-assignment}

Validators assign themselves to parachain block proposals as defined in Definition \ref{defn-para-proposal}. The assignment needs to be random. Validators use their own VRF to sign the VRF output from the current relay chain block. Each validator takes the output of this VRF mod the number of parachain blocks that we were decided to be available in this relay chain block and executed. This will give them the index of the PoV block they are assigned to and need to check.

Now in addition to this assignment some extra validators are assigned to every PoV block as follows .

No for each parachain block, let us assume we want $\#VCheck$ validators to check every PoV block during the secondary checking. Note that $VCheck$ is not a fixed number but depends on reports from collators or fishermen. Lets us $\#VDefault$ be the minimum number of validator we want to check the block, which should be the number of parachain validators plus some constant like $2$.  We set

$$\#VCheck = \#VDefault + c_f * \textrm{total fishermen stake}$$
where $c_f$ is some factor we use to weight fishermen reports. Reports from fishermen about this 

Now each validator computes for each PoV block a VRF with the input being the relay chain block VRF concatenated with the parachain index. 

For every PoV bock, every validator compares $\#VCheck - \#VDefault$ to the output of this VRF and if the VRF output is small enough than the validator checks this PoV blocks immediately otherwise depending on their difference waits for some time and only perform a check if it has not seen $\#VCheck$ checks from validators who either 1) parachain validators of this PoV block 2) or assigned during the assignment procedure or 3) had a smaller VRF output than us during this time.

More fisherman reports can increase $\#VCheck$ and require new checks. We should carry on doing secondary checks for the entire fishing period if more are required. A validator need to keep track of which blocks have $\#VCheck$ smaller than the number of higher priority checks performed. A new report can make us check straight away, no matter the number of current checks, or mean that we need to put this block back into this set. If we later decide to prune some of this data, such as who has checked the block, then we'll need a new approach here.

\subsection{VRF computation}

Every validator needs to run Algorithm \ref{algo-checker-vrf} for every Parachain $\rho$ to determines assignments. \todo{Fix this. It is incorrect so far.} 

\begin{algorithm}
  \caption[VRF-for-Approval]{\sc VRF-for-Approval($B$, $z$, $s_k$)}
  \label{algo-checker-vrf}
  \begin{algorithmic}[1]
  \Require

    $B$: the block to be approved 

    $z$: randomness for approval assignment

    $s_k$: session secret key of validator planning to participate in approval

    \State $(\pi, d) \leftarrow {\sc VRF}(H_h(B),sk(z))$
    \State \Return $(\pi,d)$
  \end{algorithmic}
\end{algorithm}

Where {\sc VRF} function is defined in \cite{polkadot-crypto-spec}.

\subsection{Additional Checking in Case of Equivocation}\label{sect-equivocation-case}
In the case of a relay chain equivocation, i.e. a validator produces two blocks with the same VRF, we do not want the secondary checkers for the second block to be predictable. To this end we use the block hash as well as the VRF as input for secondary checkers VRF. So each secondary checker is going to produce twice as many VRFs for each relay chain block that was equivocated. If either of these VRFs is small enough then the validator is assigned to perform a secondary check on the PoV block.

\section{The Approval Check}
\label{sect-approval-checking}
\subsubsection{Retrieval}
\label{sect-retrieval-of-erasure-pieces}
TBS

%%We never consider substructure of $B$ to be meaningful, so $V$ must {\em retrieve} the full {\em candidate proof-of-validity blob} $\blobB$ before checking.  Now $V$ knows which which nodes have their individual pieces, thanks to their availability announcements.  It thus follows from our 2/3rd honest assumption that $V$ could always reconstruct $\blobB$ by obtaining enough pieces $\pieces_B$ from nodes known to posses them.  

%We note however that $V$ also knows that all pieces are known by the preliminary backing validity checkers aka parachain validators who approved $\blobB$, as well as approval checkers who already approved $\blobB$.  So $V$ could first contact some node that possesses all of $\blobB$, and only then begin a full reconstruction process. 

%In both cases, $V$ must recompute $\pieces_B$ to verify $\receipt_{B,\cdot}$.  We therefore cannot see much computational difference between $V$ reconstructing $\pieces_B$ from arbitrary pieces or from $\blobB$ itself.  It remains plausible $V$ avoids some networking overhead by asking for $\blobB$ though.  We think a first implementation could reasonably target reconstructing $\pieces_B$ from arbitrary pieces, while leaving requests for the full $\blobB$ to future optimisations. 

%Ideally $V$ might retrieve the pieces in $\pieces_B$ only using its existing connections in our topology specified above, except these intentionally do not include 1/3rd of validators.  Also, $V$ need not connect to any node with all of $\pieces_B$.  Yet, $V$ should connect to at least one prachain validators in $\vals_\rho$ who ideally should check $B$ first.  

%We strongly caution against abandoning approval checkers over topology concerns because then adversarial influence over the topology could wreck our assignment criteria below.

%In fact, our retrieval component could be engineered to avoid requests entirely:  After obtaining $\pi_{V,\cdot}$, another validator $V'$ could simply compute its own priority for sending its piece from $\pieces_B$ to $V$.  We caution that doing do might become inefficient, either because $V$ winds up rejecting sends, or when many nodes go offline.  

\subsubsection{Reconstruction}
\label
After receiving $2f+1$ of erasure pieces, every assigned approval checker $v$ will run Algorithm \ref{algo-reconstruct-pov} to make sure that the code is complete and the subsequently recover the original $\blobB$.

\begin{algorithm}
  \caption[Reconstruct-PoV-Erasure]{\sc Reconstruct-PoV-Erasure($S_{Er_B}$)}
  \label{algo-reconstruct-pov-erasure}
  \begin{algorithmic}[1]
  \Require
    $S_{Er_B} := {(e_{j_1}, m_{j_1}),\cdot,(e_{j_k}, m_{j_k}))}$ such that $k > 2f$
    
  %%  \Ensure{}
    \State $\blobB \rightarrow$ {\sc Erasure-Decoder}(${e_{j_1},\cdots, e_{j_k}}$)
    \If {{\sc Erasure-Decoder} {\bf failed}}
        \State {\sc Announce-Failure}
        \State \Return
    \EndIf
    \State $Er_B \rightarrow$ {\sc Erasure-Encoder}($\blobB$)
    \If {{\sc Verify-Merkle-Proof}($S_{Er_B}$, $Er_B$) {\bf failed}}
      \State {\sc Announce-Failure}
      \State \Return
    \EndIf
    \State \Return $\blobB$
  \end{algorithmic}
\end{algorithm}

\subsection{Verification}
%%Verify
%%\If {{\sc Execute}($R_{\rho}$, $\blobB$) {\bf failed}}
%%      \State {\sc Announce-Failure}
%%      \State \Return
%%    \EndIf

Once a validator has a VRF which tells them to check a block, they announce this VRF and attempt to obtain the block. 
It is unclear yet whether this is best done by requesting the PoV block from parachain validators or by announcing that they want erasure coded pieces. 
Then they recreate the entirety of the erasure code and they execute the PoV block. 
If the erasure code does not have the claimed Merkle root, the validation function says that the PoV block is invalid or the result is inconsistent with the candidate receipt on the relay chain, then we declare the block as invalid. 
Otherwise if everything checks out correctly, we declare the block is valid. This means gossiping an attestation, including a reference that identifies candidate receipt and our VRF. 

These attestations are included in the relay chain, which must also verify the VRF and may need to judge when enough time has passed. Collators reports of unavailability and invalidty go onto the relay chain as well.

\subsection{Invalidity Escalation}\label{escalation}

When for any candidate receipt, there are attestations for both its validity and invalidity, then all validators acquire and validate the blob, irrespective of the assignments from section. We do not vote in GRANDPA for a chain were the candidate receipt is executed until it his vote is resolved. If we have $n$ validators, we wait for $>2n/3$ of them to attest to the blob and then the outcome of this vote is one of the following:

If $>n/3$ validators attest to the validity of the blob and $\leq n/3$ attest to its invalidity, then we can vote on the chain in GRANDPA again and slash validators who attested to its invalidity.

If $>n/3$ validators attest to the invalidity of the blob and $\leq n/3$ attest to its validity, then we consider the blob as invalid. If the rely chain block where the corresponding candidate receipt was executed was not finalised, then we never vote on it or build on it. We slash the validators who attested to its validity.

If $>n/3$ validators attest to the validity of the blob and $>n/3$ attest to its invalidity then we consider the blob to be invalid as above but we do not slash validators who attest either way. We want to leave a reasonable length of time in the first two cases to slash anyone to see if this happens.

