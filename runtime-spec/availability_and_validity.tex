\chapter{Availability and Validity Verification}

\section{Introduction}

Validators are responsible for guaranteeing the validity and availability of PoV blocks.
There are two phases of validation that takes place in the AnV protocol.
\newline

The primary validation check is carried out by parachain validators who are assigned to the parachain which has produced the PoV block as described in Section \ref{sect-primary-validation}. Once parachain validators have validated a parachain's PoV block successfully, they have to announce that according to the procedure described in Section \ref{sect-primary-validaty-announcement} where they generate a candidate receipt that includes the parachain header with the new state root and the XCMP message root. This candidate receipt and attestations, which carries signatures from other parachain validators is put on the relay chain.
\newline

As soon as the proposal of a PoV block is on-chain, the parachain validators break the PoV block into erasure-coded pieces as described in Section \ref{defn-erasure-coded-pieces} and distribute them among all validators. See Section \ref{sect-distribute-pieces} for details on how this distribution takes place.
\newline

Once validators have received erasure-coded pieces for several PoV blocks for the current relay chain block (that might have been proposed a couple of blocks earlier on the relay chain), they announce that they have received the erasure coded pieces on the relay chain by voting on the received pieces, see Section \ref{sect-voting-on-availability} for more details.
\newline

As soon as $>2/3$ of validators have made this announcement for any parachain block we \emph{act on} the parachain block. Acting on parachain blocks means we update the relay chain state based on the candidate receipt and considered the parachain block to have happened on this relay chain fork.
\newline

After a certain time, if we did not collect enough signatures approving the availability of the parachain data associated with a certain candidate receipt we decide this parachain block is unavailable and allow alternative blocks to be built on its parent parachain block, see \ref{sect-unavailability}.
\newline

The secondary check described in Section \ref{sect-approval-checking}, is done by one or more randomly assigned validators to make sure colluding parachain validators may not get away with validating a PoV block that is invalid and not keeping it available to avoid the possibility of being punished for the attack.
\newline

During any of the phases, if any validator announces that a parachain block is invalid then all validators obtain the parachain block and check its validity, see Section \ref{sect-escalation} for more details.
\newline

All validity and invalidity attestations go onto the relay chain, see Section \ref{sect-publishing-attestations} for details. If a parachain block has been checked at least by certain number of validators, the rest of the validators continue with voting on that relay chain block in the GRANDPA protocol. Note that the block might be challenged later.
\newline

\section{Preliminaries}

\begin{definition}
In the remainder of this chapter we assume that $\rho$ is a Polkadot Parachain and $B$ is a block which has been produced by $\rho$ and is supposed to be approved to be $\rho$'s next block. By $R_{\rho}$ we refer to runtime code of parachain $\rho$  as a WASM Blob.
\end{definition}

\begin{definition}
  \label{defn-witness-proof}
  The {\b witness proof} of block $B$, denoted by {\bf $\pi_B$}, is the set of all the external data which has gathered while the $\rho$ runtime executes block $B$. The data suffices to re-execute $R_{\rho}$ against $B$ and achieve the final state indicated in the $H(B)$.
\end{definition}

This witness proof consists of light client proofs of state data that are generally Merkle proofs for the parachain state trie.  We need this because validators do not have access to the parachain state, but only have the state root of it.

\begin{definition}
  \label{defn-pov-block}
  Accordingly we define the {\bf proof of validity block} or {\bf PoV} block in
  short, {\bf $\PoVB$}, to be the tuple:
  \[
  (B, \pi_B)
  \]
\end{definition}

\begin{definition}  \label{defn-extra-validation-data}
  The \textbf{extra validation data} $v_B$  is an extra input to the validation
  function, i.e. additional data from the relay chain state that is needed.
  It's a tuple of the following format:
  \[
  (Head_p(B), balance, Blake2b(R_\rho), R_u)
  \]

  Where $Head_p(B)$ refers to the head data of parachain block $B$ as defined in
  Definition \ref{defn-head-data}, $balance$ refers to the balance of the
  parachain at the moment of validation \todo{@fabio: clarify} and
  $Blake2b(R_\rho)$ is the 32-byte Blake2 hash of the Runtime code of the
  parachain. $R_u$ is a varying data type as defined in Definition X
  \todo{@fabio} and can be one of the following values:

  \begin{equation}
    R_u =
    \begin{cases}
      0, & \text{None} \\
      1, & \text{followed by: } H_i(B_n)
    \end{cases}
  \end{equation}

  $R_u$ implies whether the parachain is allowed to upgrade its validation code.
  If it's of type $1$, it contains the number of the minimum relay chain height
  at which the upgrade will be applied, assuming a upgrade is currently signaled
  \todo{@fabio: where is this signaled?}
  \newline

  Parachain validators get this extra validation data from the current relay
  chain state. Note that a PoV block can be paired with different extra
  validation data depending on when and which relay chain fork it is included
  in. Future validators would need this extra validation data because since the
  candidate receipt as defined in Definition \ref{defn-candidate-receipt} was included on the relay chain the needed relay chain state
  may have changed.
\end{definition}

\begin{definition}
  \label{defn-blob}
  Accordingly we define the {\bf erasure coding blob} or {\bf blob} in short, {\bf $\blobB$} to be the tuple:
  \[
  (B, \pi_B, v_B)
  \]
\end{definition}

Note that in the code the blob is referred to as "AvailableData".


\section{Overal process}

The Figure \ref{diag-anv-overall} demonstrates the overall process of assuring availability and validity in Polkadot \todo{complete the Diagram}.

\begin{figure}[h!]
\label{diag-anv-overall}
\begin{plantuml}
%%    
@startuml

(*) --> "<math>Parachain Collator $C_\rho$ Generates  $B$ and $PoV_B$</math>"
    --> "<math>$C_\rho$ sends $PoV_B$ to $\rho$'s validator $V_\rho$</math>"
    --> "<math>$V_{\rho}$ runs $\rho$'s runtime on PoV</math>"
    if "<math>$PoV_B$ is valid</math>" then
    -->[true] if  "<math>$V_{\rho}$ have seen the CandidateReceipt for $PoV_B$</math>" then
    -->[true] Sign CandidateReceipt
    -->[Ending process] (*)

    else
    --> [False] "Gerenate CandiateReceipt"
    -->[Ending process] (*)

    endif
    else
    -->[false] "<math>Broadcast message of invalidity for $PoV_B$</math>"
    end if

  -->[Ending process] (*)

@enduml
\end{plantuml}
\caption{Overall process to acheive availability and validity in Polkadot}
\end{figure}

\section{Primary Validation}
\label{sect-primary-validation}

Collators produce candidates as defined in Definition \ref{defn-candidate}.
Validators verify the validity of the received candidates as described in
Algorithm \ref{algo-primary-validation}. \todo{@fabio: confirm this} Validators
back the validity respectively the invalidity by extending the candidates into 
candidate receipts as defined in Definition \ref{defn-candidate-receipt} and
communicate it by issuing statements as defined in Definition
\ref{defn-gossip-statement}.
\newline

The validator ensures the that every candidate considered for inclusion has at least
one other validator backing it. Candidates without backing are discarded. Backed candidates 
which later prove to be invalid qualify the backer for slashing.
\newline

It's note worthy that validators do not dictate which candidates are prioritized
for inclusion. Each validator decides for itself - on whatever metric - which
\textit{valid} candidates to include.

\begin{definition}
  \label{defn-candidate}
  A \textbf{candidate}, $C_{coll}(PoV_B)$, is issues by collators and contains the PoV
  block and enough data in order for any validator to verify its validity. A
  candidate is a tuple of the following format:
  \[
  C_{coll}(PoV_B) := (id_p, h_b({B_{^{relay}_{parent}}}), id_{C}, Sig^{Collator}_{SR25519}, Head_p(B), h_b({PoV_B}))
  \]

  where each value represents:
  \begin{itemize}
    \item $id_p$: the Parachain Id this candidate is for.
    \item $h_b({B_{^{relay}_{parent}}})$: the hash of the relay chain block that this
    candidate should be executed in the context of.
    \item $id_C$: the Collator relay-chain account ID as defined in Definition
    \todo{@fabio}.
    \item $Sig^{Collator}_{SR25519}$: the signature on the 256-bit Blake2 hash
    of the block data by the collator.
    \item $Head_p(B)$: the head data of parachain block $B$ as defined in
    Definition \ref{defn-head-data}. \todo{@fabio (collator module relevant?)}.
    \item $h_b({PoV_B})$: the hash of the PoV block.
    \todo{@fabio}.
  \end{itemize}

\end{definition}

\begin{definition}
  \label{defn-head-data}
  The \textbf{head data}, $Head_p(B)$, of a parachain block is a tuple of the following format:
  \[
    (H_i(B), H_p(B), H_r(B))
  \]

  Where $H_i(B)$ is the block number of parachain block $B$, $H_p(B)$ is the
  32-byte Blake2 hash of the parent block header and $H_r(B)$ represents the
  root of the post-execution state.
  \todo{@fabio: clarify if $H_p$ is the hash of the header or full block}
  \todo{@fabio: maybe define those symbols at the start (already defined in the Host spec)?}
\end{definition}

\begin{algorithm}[H]
  \caption[]{\sc PrimaryValidation}
  \label{algo-primary-validation}
  \begin{algorithmic}[1]
    \Require{$B$, $\pi_B$, relay chain parent block $B^{relay}_{parent}$}
    %%  \Ensure{}

    \State Retrieve $v_B$ from the relay chain state at $B^{relay}_{parent}$
    \State Run Algorithm \ref{algo-validate-block} using $B, \pi_B, v_B$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption[]{\sc ValidateBlock}
  \label{algo-validate-block}
  \begin{algorithmic}[1]
    \Require{$B, \pi_B, v_B$}
    %%  \Ensure{}
    \State retrieve the runtime code $R_\rho$ that is specified by $v_B$ from the relay chain state.
    \State check that the initial state root in $\pi_B$ is the one claimed in $v_B$
    \State Execute $R_\rho$ on $B$ using $\pi_B$ to simulate the state.
    \State If the execution fails, return fail.
    \State Else return success, the new header data $h_B$ and the outgoing messages $M$. \todo{@fabio: same as head data?}
  \end{algorithmic}
\end{algorithm}

\subsection{Primary validity announcement}
\label{sect-primary-validaty-announcement}
Validator $v$ needs to perform Algorithm \ref{algo-primary-validation-announcement} to announce the result of primary validation to the Polkadot network.
\newline

In case that validation has been successful, the announcement will either be in
the form of sending the candidate receipt for block $B$ as defined in Definition
\ref{defn-candidate-receipt} to the relay chain or confirm a candidate receipt
sent in from another parachain validators for this block according to Algorithm
\ref{algo-endorse-candidate-receipt}. However, if the validation fails, $v$
reacts by executing Algorithm \ref{algo-announce-primary-validation-failure}.

\begin{definition}
  \label{defn-candidate-receipt}
  A \textbf{candidate receipt}, $C_{receipt}(PoV_B)$, is an extension of a candidate
  as defined in Definition \ref{defn-candidate} which includes additional
  information about the validator which verified the PoV block. The candidate
  receipt is communicated to other validators by issuing a statement as defined
  in Definition \ref{defn-gossip-statement}.
  \newline

  This type is a tuple of the following format:
  \[
  C_{receipt}(PoV_B) := (id_p, h_b({B_{^{relay}_{parent}}}), Head_p(B), id_{C}, Sig^{Collator}_{SR25519}, h_b({PoV_B}), \mathbb{C})
  \]

  where each value represents:
  \begin{itemize}
    \item $id_p$: the Parachain Id this candidate is for.
    \item $h_b({B_{^{relay}_{parent}}})$: the hash of the relay chain block that this
    candidate should be executed in the context of.
    \item $Head_p(B)$: the head data of parachain block $B$ as defined in Definition \ref{defn-head-data}.
    \todo{@fabio (collator module relevant?)}.
    \item $id_C$: the Collator relay-chain account ID as defined in Definition
    \todo{@fabio}.
    \item $Sig^{Collator}_{SR25519}$: the signature on the 256-bit Blake2 hash
    of the block data by the collator.
    \item $h_b({PoV_B})$: the hash of the PoV block.
    \item $\mathbb{C}(PoV_B)$: Commitments made as a result of validation, as described in
    \todo{@fabio}.
  \end{itemize}
\end{definition}

\begin{definition}
  \label{defn-candidate-commitments}
  \textbf{Candidate commitments}, $\mathbb{C}(PoV_B)$, are results of the execution and validation of
  parachain (or parathread) candidates whose produced values must be committed
  to the relay chain. A candidate commitments is represented as a tuple of the following format:
  \begin{alignat*}{2}
    \mathbb{C}(PoV_B) &:= (fees, Enc_{SC}(Msg_0, .., Msg_n), H_r(B), \mathbb{U}(R_\rho)) \\
    Msg &:= (\mathbb{P}, Enc_{SC}(b_0,.. b_n))
  \end{alignat*}

  where each value represents:
  \begin{itemize}
    \item $fees$: fees paid from the chain to the relay chain validators.
    \item $Msg$: parachain messages to the relay chain. $\mathbb{P}$ identifies
    the origin of the messages and is a varying data type as defined in
    Definition \todo{@fabio} and can be one of the following values:
    \begin{equation*}
      \mathbb{P} =
      \begin{cases}
        0, & \text{Signed} \\
        1, & \text{Parachain} \\
        2, & \text{Root}
      \end{cases}
    \end{equation*}
    \todo{@fabio: define the concept of "origin"}

    The following SCALE encoded array, $Enc_{SC}(b_0,.. b_n)$, contains the
    raw bytes of the message which varies in sizes.
    \item $H_r(B)$: the root of a block's erase encoding Merkle tree
    \todo{@fabio: use different symbol for this?}.
    \item $\mathbb{U(R_\rho)}$: A varying datatype as defined in Definition
    \todo{@fabio} and can contain one of the following values:
    \begin{equation*}
      \mathbb{P} =
      \begin{cases}
        0, & \text{None} \\
        1, & \text{followed by: } R_\rho\\
      \end{cases}
    \end{equation*}
    where $R_\rho$ is a SCALE encoded array containing the new runtime code for
    the parachain. \todo{@fabio: clarify further}
  \end{itemize}
  
\end{definition}

\begin{definition}
  \label{defn-pov-block}
  A \textbf{Gossip PoV block} is a tuple of the following format:
  \[
  (h_b(B_{^{relay}_{parent}}), h_b(candidate), PoV_B)
  \]
  where $h_b(B_{^{relay}_{parent}})$ is the block hash of the relay chain being
  referred to and $h_b(candidate)$ is the hash of some candidate localized to
  the same Relay chain block, whose PoV block is $_b(candidate)$.
\end{definition}

\begin{definition}
  \label{defn-gossip-statement}
  A \textbf{statement} notifies other validators about the validity of a PoV block.
  This type is a tuple of the following format:
  \[
  (Stmt, id_{\mathbb{V}}, Sig^{Valdator}_{SR25519})
  \]
  where $Sig^{Validator}_{SR25519}$ is the signature of the validator and
  $id_{\mathbb{V}}$ refers to the index of validator according to the authority
  set. \todo{@fabio: define authority set (specified in the Host spec)}. $Stmt$
  refers to a statement the validator wants to make about a certain candidate.
  $Stmt$ is a varying datatype as defined in X \todo{@fabio: define} and can be one
  of the following values:

\begin{equation}
  Stmt =
  \begin{cases}
    0, & \text{Seconded, followed by: } C_{receipt}(PoV_B) \\
    1, & \text{Validity, followed by: } Blake2(C_{coll}(PoV_B)) \\
    2, & \text{Invalidity, followed by: } Blake2(C_{coll}(PoV_B))
  \end{cases}
\end{equation}
\end{definition}

The main semantic difference between `Seconded` and `Valid` comes from the fact
that every validator may second only one candidate per relay chain block; this
places an upper bound on the total number of candidates whose validity needs to
be checked. A validator who seconds more than one parachain candidate per relay
chain block is subject to slashing.
\newline

Validation does not directly create a seconded statement, but is rather upgraded
by the validator when it choses to back a valid candidate as described in
Algorithm \ref{algo-primary-validation-announcement}.

\begin{algorithm}[H]
  \caption[PrimaryValidationAnnouncement]{\sc PrimaryValidationAnnouncement}
  \label{algo-primary-validation-announcement}
  \begin{algorithmic}[1]
    \Require{$PoV_B$}
      \State \textbf{Init} $Stmt$;
      \If {\textsc{ValidateBlock($PoV_B$)} is \textbf{valid}}
        \State $Stmt \leftarrow$ \textsc{SetValid($PoV_B$)}
      \Else
        \State $Stmt \leftarrow$ \textsc{SetInvalid($PoV_B$)}
      \EndIf
      \State \textsc{Propagate}($Stmt$)
  \end{algorithmic}
\end{algorithm}

\begin{itemize}
  \item \textsc{ValidateBlock}: Validates $PoV_B$ as defined in Algorithm
  \ref{algo-validate-block}.
  \item \textsc{SetValid}: Creates a valid statement as defined in Definition
  \ref{defn-gossip-statement}.
  \item \textsc{SetInvalid}: Creates an invalid statement as defined in
  Definition \ref{defn-gossip-statement}.
\end{itemize}

\begin{algorithm}[H]
  \caption[]{\sc ConfirmCandidateReceipt}
  \label{algo-endorse-candidate-receipt}
  \begin{algorithmic}[1]
    \Require{$PoV_B$}
      \State \textbf{Init} $Stmt$;
      \If {\textsc{ValidateBlock($PoV_B$)} is \textbf{valid}}
        \If {\textsc{AlreadySeconded($B^{relay}_{chain}$)}}
          \State $Stmt \leftarrow$ \textsc{SetValid($PoV_B$)}
        \Else
          \State $Stmt \leftarrow$ \textsc{SetSeconded($PoV_B$)}
        \EndIf
      \Else
        \State $Stmt \leftarrow$ \textsc{SetInvalid($PoV_B$)}
      \EndIf
      \State \textsc{Propagate}($Stmt$)
  \end{algorithmic}
\end{algorithm}

\begin{itemize}
  \item \textsc{ValidateBlock}: Validates $PoV_B$ as defined in Algorithm
  \ref{algo-validate-block}.
  \item \textsc{AlreadySeconded}: Verifies if a block has already been seconded
  for the given Relay Chain block. Validators that second more than one (1)
  block per Relay chain block are subject to slashing. More information is
  available in Definition \ref{defn-gossip-statement}.
  \item \textsc{SetValid}: Creates a valid statement as defined in Definition
  \ref{defn-gossip-statement}.
  \item \textsc{SetSeconded}: Creates a seconded statement as defined in
  Definition \ref{defn-gossip-statement}. Seconding a block should ensure that
  the next call to \textsc{AlreadySeconded} reliably affirms this action.
  \item \textsc{SetInvalid}: Creates an invalid statement as defined in
  Definition \ref{defn-gossip-statement}.
\end{itemize}

\begin{algorithm}[H]
  \caption[]{\sc AnnouncePrimaryValidationFailure}
  \label{algo-announce-primary-validation-failure}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}

    \State TBS
  \end{algorithmic}
\end{algorithm}

\subsection{Inclusion of candidate receipt on the relay chain}\label{sect-inclusion-of-candidate-receipt}

\begin{definition}
  \label{defn-para-proposal}
        {\b Parachain Block Proposal}, noted by $P^B_{\rho}$is a candidate receipt for a parachain block $B$ for a parachain $\rho$ along with signatures for at least 2/3 of $\mathcal{V}_\rho$.  %\syed{and no invalidity for it}{TBS how to deal with message of invalidity announcement}. We still include the proposal if a parachain validator attests to its invalidity, Any primary invalidity attestation or late primary validity attestation are handled just like secondary attestations.

\end{definition}

A block producer which observe a Parachain Block Proposal as defined in definition \ref{defn-para-proposal} \syed{may/should}{?} include the proposal in the block they are producing according to Algorithm \ref{algo-include-parachain-proposal} during block production procedure.

\begin{algorithm}[H]
  \caption[]{\sc IncludeParachainProposal($P^B_{\rho}$)}
  \label{algo-include-parachain-proposal}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}

    \State TBS
  \end{algorithmic}
\end{algorithm}


\subsection{Primary Validation Disagreement}
\label{sect-primary-validation-disagreemnt}
\syed{Parachain}{verify} validators need to keep track of candidate receipts (see Definition \ref{defn-candidate-receipt}) and validation failure messages of their peers. In case, there is a disagreement among the parachain validators about $\blobB$, all parachain validators must invoke Algorithm \ref{algo-primary-validation-disagreemnt}

\begin{algorithm}[H]
  \caption[]{\sc PrimaryValidationDisagreement}
  \label{algo-primary-validation-disagreemnt}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}

    \State TBS
  \end{algorithmic}
\end{algorithm}

\section{Availability}

When a $v \in \paraValidSet$ observes that a block containing parachain block candidate receipt is included in a relay chain block $RB_p$ then it must invoke Algorithm \ref{algo-erasure-encode}.

\begin{definition}
  \label{defn-erasure-encoder-decoder}
  The {\bf erasure encoder/decoder} {\bf $encode_{k,n}/decoder_{k,n}$ } is defined to be the Reed-Solomon encoder defined in \cite{??}.
\end{definition}

\begin{algorithm}[H]
  \caption[]{\sc Erasure-Encode($\blobB$, $n$}
  \label{algo-erasure-encode}
  \begin{algorithmic}[1]
  \Require
    $\blobB$: blob defined in Definition \ref{defn-blob}

    \State TBS
  \end{algorithmic}
\end{algorithm}

\begin{definition}
  \label{defn-erasure-coded-pieces}
  The {\bf set of erasure encode pieces} of $\blobB$, denoted by:
  \[
   Er_B := {(e_1, m_1),...,(e_n,m_n)}
   \]
   is defined to be the output of the Algorithm \ref{algo-erasure-encode}.
\end{definition}

\section{Distribution of Pieces}\label{sect-distribute-pieces}
Following the computation of $Er_B$, $v$ must construct the $\blobB$ Availability message defined in Definition \ref{defn-pov-erasure-piece-message}. And distribute them to target validators designated by the Availability Networking Specification \cite{??}.

\begin{definition}
  \label{defn-pov-erasure-piece-message}
        {\b PoV erasure piece message} $M_{PoV_{\blobB}}(i)$ is TBS
\end{definition}

\section{Announcing Availability}\label{sect-voting-on-availability}

When validator $v$ receives its designated piece for \blobB it needs to broadcast Availability vote message as defined in Definition\ref{defn-availability-vote-message}
\begin{definition}
  \label{defn-availability-vote-message}
        {\b Availability vote message} $M_{PoV}^{Avail,v_i}$ TBS
\end{definition}

Some parachains have blocks that we need to vote on the availability of, that is decided by > 2/3 of validators voting for availability. \syed{For 100 parachain and 1000 validators this will involve putting 100k items of data and processing them on-chain for every relay chain block, hence we want to use bit operations that will be very efficient. We describe next what operations the relay chain runtime uses to process these availability votes.}{this is not really relevant to the spec}
\newline

For each parachain, the relay chain stores the following data: %/syed{we store}{what does it mean we store? this need to be clear. Is it a transaction TBS?}: no its not a tx, its in the relay chain state

\textbf{1) availability status, 2) candidate receipt, 3) candidate relay chain block number}

where availability status is one of \{no candidate, to be determined, unavailable, available\} .

For each block, each validator $v$ signs a message

Sign(bitfield $b_v$, block hash $h_b$)

where the $i$th bit of $b_v$ is $1$ if and only if

\begin{enumerate}
\item the availability status of the candidate receipt is "to be determined" on the relay chain at block hash $h_b$ \textbf{and}

\item $v$ has the erasure coded piece of the corresponding parachain block to this candidate receipt.
\end{enumerate}

These signatures go into a relay chain block.

\subsection{Processing on-chain availability data}
This section explains how the availability attestations stored on the relay chain, as described in Section ??, are processed as follows:

\begin{algorithm}[H]
  \caption[]{Relay chain's signature processing}
  \label{algo-singnature-processing}
  \begin{algorithmic}[1]
%\begin{enumerate}
\State The relay chain stores the last vote from each validator on chain. For each new signature, the relay chain checks if it is for a block in this chain later than the last vote stored from this validator. If it is the relay chain updates the stored vote and updates the bitfield $b_v$ and block number of the vote.
\State For each block within the last $t$ blocks where $t$ is some timeout period, the relay chain computes a bitmask $bm_n$ ($n$ is block number). This bitmask is a bitfield that represents whether the candidate considered in that block is still relevant. That is the $i$th bit of $bm_n$ is $1$ if and only if for the $i$th parachain,
    (a) the availability status is to be determined and
    (b) candidate block number $\leq n$
\State The relay chain initialises a vector of counts with one entry for each parachain to zero. After executing the following algorithm it ends up with a vector of counts  of the number of validators who think the latest candidates is available.
	\begin{enumerate}
    \item The relay chain computes
    $b_v$ and $bm_n$
    where $n$ is the block number of the validator's last vote
   \item For each bit in $b_v$ and $bm_n$
		\begin{itemize}
        \item add the $i$th bit to the $i$th count.
        \end{itemize}
	\end{enumerate}
\State For each count that is $>2/3$ of the number of validators, the relay chain sets the candidates status to "available". Otherwise, if the candidate is at least $t$ blocks old, then it sets its status to "unavailable".
\State The relay chain acts on available candidates and discards unavailable ones, and then clears the record, setting the availability status to "no candidate". Then the relay chain accepts new candidate receipts for parachains that have "no candidate: status and once any such new candidate receipts is included on the relay chain it sets their availability status as "to be determined".
%\end{enumerate}
\end{algorithmic}
\end{algorithm}

Based on the result of Algorithm~\ref{algo-signature-processing} the validator node should mark a parachain block as either available or eventually unavailable according to definitions \ref{defn-available-parablock-proposal} and \ref{defn-unavailable-parablock-proposal}
\begin{definition}
  \label{defn-available-parablock-proposal}
        Parachain blocks for which the corresponding blob is  noted on the relay chain to be {\b available}, meaning that the candidate receipt has been voted to be available by 2/3 validators.
\end{definition}

After a certain time-out in blocks since we first put the candidate receipt on the relay chain if there is not enough votes of availability the relay chain logic decides that a parachain block is unavailable, see \ref{algo-singnature-processing}.

\begin{definition}
  \label{defn-unavailable-parachain-block}
       An {\b unavailabile parachain block} is TBS
\end{definition}

/syed{}{So to be clear we are not announcing unavailability we just keep it for grand pa vote}

\section{Publishing Attestations}
\label{sect-publishing-attestations}
\syed{}{this is out of place. We can mentioned that we have two type of (validity) attestations in the intro but we just need to spec each attestation in its relevant section (which we did with the candidate receipt).
  \todo{move this to intro}}
We have two type of attestations, primary and secondary. Primary attestations are signed by the parachain validators and secondary attestations are signed by secondary checkers and include the VRF that assigned them as a secondary checker into the attestation. Both types of attestations are included in the relay chain block as a transaction. For each parachain block candidate the relay chain keeps track of which validators have attested to its validity or invalidity.

\section{Secondary Approval checking}
\label{sect-approval-checking}
Once a parachain block is acted on we carry the secondary validity/availability checks as follows. A scheme assigns every validator to one or more PoV blocks to check its validity, see Section \ref{sect-shot-assignment} for details. An assigned validator acquires the PoV block (see Section \ref{sect-obtaining-block}) and checks its validity by comparing it to the candidate receipt. If validators notices that an equivocation has happened an additional validity/availability assignments will be made that is described in Section\ref{sect-equivocation-case}.

\subsection{Approval Checker Assignment}

Validators assign themselves to parachain block proposals as defined in Definition \ref{defn-para-proposal}. The assignment needs to be random. Validators use their own VRF to sign the VRF output from the current relay chain block as described in Section \ref{sect-vrf-comp}. Each validator uses the output of the VRF to decide the block(s) they are revalidating as a secondary checker. See Section \ref{one-shot-assigment} for the detail.
\newline

In addition to this assignment some extra validators are assigned to every PoV block which is descirbed in Section \ref{sect-extra-validation assignment}.

\subsection{VRF computation}
\label{sect-vrf-comp}

Every validator needs to run Algorithm \ref{algo-checker-vrf} for every Parachain $\rho$ to determines assignments. \todo{Fix this. It is incorrect so far.}

\begin{algorithm}[H]
  \caption[VRF-for-Approval]{\sc VRF-for-Approval($B$, $z$, $s_k$)}
  \label{algo-checker-vrf}
  \begin{algorithmic}[1]
  \Require

    $B$: the block to be approved

    $z$: randomness for approval assignment

    $s_k$: session secret key of validator planning to participate in approval

    \State $(\pi, d) \leftarrow {VRF}(H_h(B),sk(z))$
    \State \Return $(\pi,d)$
  \end{algorithmic}
\end{algorithm}

Where {\sc VRF} function is defined in \cite{polkadot-crypto-spec}.
\newline

\subsection{One-Shot Approval Checker Assignemnt}
\label{sect-shot-assignment}
Every validator $v$ takes the output of this VRF computed by \ref{algo-checker-vrf} mod the number of parachain blocks that we were decided to be available in this relay chain block according to Definition \ref{defn-available-parablock-proposal} and executed. This will give them the index of the PoV block they are assigned to and need to check. The procedure is formalised in \ref{algo-one-shot-assignment}.

\begin{algorithm}[H]
  \caption[]{\sc OneShotAssignment}
  \label{algo-one-shot-assignment}
  \begin{algorithmic}[1]
    \Require{}
    %\Ensure{}

    \State TBS
  \end{algorithmic}
\end{algorithm}

\subsection{Extra Approval Checker Assigment}
\label{sect-extra-validation}
Now for each parachain block, let us assume we want $\#VCheck$ validators to check every PoV block during the secondary checking. Note that $\#VCheck$ is not a fixed number but depends on reports from collators or fishermen. Lets us $\#VDefault$ be the minimum number of validator we want to check the block, which should be the number of parachain validators plus some constant like $2$.  We set

$$\#VCheck = \#VDefault + c_f * \textrm{total fishermen stake}$$
where $c_f$ is some factor we use to weight fishermen reports. Reports from fishermen about this
\newline

Now each validator computes for each PoV block a VRF with the input being the relay chain block VRF concatenated with the parachain index.
\newline

For every PoV bock, every validator compares $\#VCheck - \#VDefault$ to the output of this VRF and if the VRF output is small enough than the validator checks this PoV blocks immediately otherwise depending on their difference waits for some time and only perform a check if it has not seen $\#VCheck$ checks from validators who either 1) parachain validators of this PoV block 2) or assigned during the assignment procedure or 3) had a smaller VRF output than us during this time.
\newline

More fisherman reports can increase $\#VCheck$ and require new checks. We should carry on doing secondary checks for the entire fishing period if more are required. A validator need to keep track of which blocks have $\#VCheck$ smaller than the number of higher priority checks performed. A new report can make us check straight away, no matter the number of current checks, or mean that we need to put this block back into this set. If we later decide to prune some of this data, such as who has checked the block, then we'll need a new approach here.

\begin{algorithm}[H]
  \caption[]{\sc OneShotAssignment}
  \label{algo-extra-assignment}
  \begin{algorithmic}[1]
    \Require{}
    %\Ensure{}

    \State TBS
  \end{algorithmic}
\end{algorithm}

\syed{}{\todo{so assignees are not announcing their assignment just the result of the approval check I assume}}

\subsection{Additional Checking in Case of Equivocation}\label{sect-equivocation-case}
In the case of a relay chain equivocation, i.e. a validator produces two blocks with the same VRF, we do not want the secondary checkers for the second block to be predictable. To this end we use the block hash as well as the VRF as input for secondary checkers VRF. So each secondary checker is going to produce twice as many VRFs for each relay chain block that was equivocated. If either of these VRFs is small enough then the validator is assigned to perform a secondary check on the PoV block. The process is formalized in Algorithm \ref{algo-equivocation-assigment}

\begin{algorithm}[H]
  \caption[]{\sc EquivocatedAssignment}
  \label{algo-equivocation-assigment}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}

    \State TBS
  \end{algorithmic}
\end{algorithm}


\section{The Approval Check}
Once a validator has a VRF which tells them to check a block, they announce this VRF and attempt to obtain the block.
It is unclear yet whether this is best done by requesting the PoV block from parachain validators or by announcing that they want erasure coded pieces.

\subsubsection{Retrieval}
\label{sect-retrieval-of-erasure-pieces}
There are two fundamental ways to retrieve a parachain block for checking validity. One is to request the whole block from any validator who has attested to its validity or invalidity. Assigned appoval checker $v$ sends RequestWholeBlock message specified in Definition \ref{defn-msg-request-whole-block} to \syed{}{any/all} parachain validator in order to receive the specific parachain block. Any parachain validator receiving must reply with PoVBlockRespose message defined in Definition \ref{defn-pov-block-response}

\begin{definition}
  \label{defn-pov-block-response}
        {\b PoV Block Respose} Message TBS
\end{definition}

The second method is to retrieve enough erasure coded pieces to reconstruct the block from them. In the latter cases an announcement of the form specified in Definition has to be gossiped to all validators indicating that one needs the erasure coded pieces.

\begin{definition}
  \label{defn-erasure-coded-pieces-request}
        {\b Erasure coded pieces request message} TBS
\end{definition}

On their part, when a validator  receive a erasure coded pieces request message it response with the message specified in Definition \ref{defn-erasure-coded-pieces-response}.

\begin{definition}
  \label{defn-erasure-coded-pieces-response}
        {\b Erasure coded pieces response message} TBS
\end{definition}

Assigned appoval checker $v$ must retrieve enough erasure pieces of the block they are verifying to be able to reconstruct the block and the erasure pieces tree.

%%To that aim the
%%We never consider substructure of $B$ to be meaningful, so $V$ must {\em retrieve} the full {\em candidate proof-of-validity blob} $\blobB$ before checking.  Now $V$ knows which which nodes have their individual pieces, thanks to their availability announcements.  It thus follows from our 2/3rd honest assumption that $V$ could always reconstruct $\blobB$ by obtaining enough pieces $\pieces_B$ from nodes known to posses them.

%We note however that $V$ also knows that all pieces are known by the preliminary backing validity checkers aka parachain validators who approved $\blobB$, as well as approval checkers who already approved $\blobB$.  So $V$ could first contact some node that possesses all of $\blobB$, and only then begin a full reconstruction process.

%In both cases, $V$ must recompute $\pieces_B$ to verify $\receipt_{B,\cdot}$.  We therefore cannot see much computational difference between $V$ reconstructing $\pieces_B$ from arbitrary pieces or from $\blobB$ itself.  It remains plausible $V$ avoids some networking overhead by asking for $\blobB$ though.  We think a first implementation could reasonably target reconstructing $\pieces_B$ from arbitrary pieces, while leaving requests for the full $\blobB$ to future optimisations.

%Ideally $V$ might retrieve the pieces in $\pieces_B$ only using its existing connections in our topology specified above, except these intentionally do not include 1/3rd of validators.  Also, $V$ need not connect to any node with all of $\pieces_B$.  Yet, $V$ should connect to at least one prachain validators in $\vals_\rho$ who ideally should check $B$ first.

%We strongly caution against abandoning approval checkers over topology concerns because then adversarial influence over the topology could wreck our assignment criteria below.

%In fact, our retrieval component could be engineered to avoid requests entirely:  After obtaining $\pi_{V,\cdot}$, another validator $V'$ could simply compute its own priority for sending its piece from $\pieces_B$ to $V$.  We caution that doing do might become inefficient, either because $V$ winds up rejecting sends, or when many nodes go offline.

\subsubsection{Reconstruction}
\label{}
After receiving $2f+1$ of erasure pieces every assigned approval checker $v$ needs to recreate the entirety of the erasure code, hence every $v$ will run Algorithm \ref{algo-reconstruct-pov} to make sure that the code is complete and the subsequently recover the original $\blobB$.

\begin{algorithm}[H]
  \caption[Reconstruct-PoV-Erasure]{\sc Reconstruct-PoV-Erasure($S_{Er_B}$)}
  \label{algo-reconstruct-pov-erasure}
  \begin{algorithmic}[1]
  \Require
    $S_{Er_B} := {(e_{j_1}, m_{j_1}),\cdot,(e_{j_k}, m_{j_k}))}$ such that $k > 2f$

  %%  \Ensure{}
    \State $\blobB \rightarrow$ {\sc Erasure-Decoder}(${e_{j_1},\cdots, e_{j_k}}$)
    \If {{\sc Erasure-Decoder} {\bf failed}}
        \State {\sc Announce-Failure}
        \State \Return
    \EndIf
    \State $Er_B \rightarrow$ {\sc Erasure-Encoder}($\blobB$)
    \If {{\sc Verify-Merkle-Proof}($S_{Er_B}$, $Er_B$) {\bf failed}}
      \State {\sc Announce-Failure}
      \State \Return
    \EndIf
    \State \Return $\blobB$
  \end{algorithmic}
\end{algorithm}

\subsection{Verification}
%%Verify
%%\If {{\sc Execute}($R_{\rho}$, $\blobB$) {\bf failed}}
%%      \State {\sc Announce-Failure}
%%      \State \Return
%%    \EndIf

Once the parachain bock has been obtained or reconstructed the secondary checker needs to execute the PoV block.
We declare a the candidate receipt as invalid if one one the following three conditions hold: 1) While reconstructing if the erasure code does not have the claimed Merkle root, 2) the validation function says that the PoV block is invalid, or 3) the result  of executing the block is inconsistent with the candidate receipt on the relay chain.

The procedure is formalized in Algorithm


\begin{algorithm}[H]
  \caption[]{\sc RevalidatingReconstructedPoV}
  \label{algo-revalidating-reconstructed-pov}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}

    \State TBS
  \end{algorithmic}
\end{algorithm}

If everything checks out correctly, we declare the block is valid. This means gossiping an attestation, including a reference that identifies candidate receipt and our VRF as specified in Definition \ref{defn-secondary-appoval-attestation}.

\begin{definition}
  \label{defn-secondary-appoval-attestation}
        {\b Secondary approval attetstion message} TBS
\end{definition}


\subsection{Process validity and invalidity messages}
When a Black produced receive a Secondary approval attetstion message, it execute Algorithm \ref{algo-verify-approval-attestation} to verify the VRF and may need to judge when enough time has passed.

\begin{algorithm}[H]
  \caption[]{\sc VerifyApprovalAttestation}
  \label{algo-verify-approval-attestation}
  \begin{algorithmic}[1]
    \Require{}
    %%  \Ensure{}

    \State TBS
  \end{algorithmic}
\end{algorithm}

These attestations are included in the relay chain as a transaction specified in

\begin{definition}
  \label{defn-approval-attestation-transaction}
        {\b Approval Attestation Transaction} TBS
\end{definition}

Collators reports of unavailability and invalidty specified in Definition \todo{Define these messages} also  go onto the relay chain as well in the format specified in Definition

\begin{definition}
  \label{defn-collator-invalidity-transaction}
        {\b Collator Invalidity Transaction}
        TBS
\end{definition}

\begin{definition}
  \label{defn-collator-unavailability-transaction}
        {\b Collator unavailability Transaction}
\end{definition}

\subsection{Invalidity Escalation}\label{escalation}

When for any candidate receipt, there are attestations for both its validity and invalidity, then all validators acquire and validate the blob, irrespective of the assignments from section by executing Algorithm \ref{algo-reconstruct-pov} and \ref{algo-revalidating-reconstructed-pov}.
\newline

We do not vote in GRANDPA for a chain were the candidate receipt is executed until its vote is resolved. If we have $n$ validators, we wait for $>2n/3$ of them to attest to the blob and then the outcome of this vote is one of the following:
\newline

If $>n/3$ validators attest to the validity of the blob and $\leq n/3$ attest to its invalidity, then we can vote on the chain in GRANDPA again and slash validators who attested to its invalidity.
\newline

If $>n/3$ validators attest to the invalidity of the blob and $\leq n/3$ attest to its validity, then we consider the blob as invalid. If the rely chain block where the corresponding candidate receipt was executed was not finalised, then we never vote on it or build on it. We slash the validators who attested to its validity.
\newline

If $>n/3$ validators attest to the validity of the blob and $>n/3$ attest to its invalidity then we consider the blob to be invalid as above but we do not slash validators who attest either way. We want to leave a reasonable length of time in the first two cases to slash anyone to see if this happens.
