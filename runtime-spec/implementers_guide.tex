\chapter{Implementer's Guide}

\section{Ramble / Preamble}

This document aims to describe the purpose, functionality, and implementation of
a host for Polkadot's parachains. It is not for the implementor of a specific
parachain but rather for the implementor of the Parachain Host, which provides
security and advancement for constituent parachains. In practice, this is for
the implementors of Polkadot.
\newline

There are a number of other documents describing the research in more detail.
All referenced documents will be linked here and should be read alongside this
document for the best understanding of the full picture. However, this is the
only document which aims to describe key aspects of Polkadot's particular
instantiation of much of that research down to low-level technical details and
software architecture.

\section{Origins}

Parachains are the solution to a problem. As with any solution, it cannot be
understood without first understanding the problem. So let's start by going over
the issues faced by blockchain technology that led to us beginning to explore
the design space for something like parachains.

\subsection{Issue 1: Scalability}

It became clear a few years ago that the transaction throughput of simple
Proof-of-Work (PoW) blockchains such as Bitcoin, Ethereum, and myriad others was
simply too low. \todo{PoS, sharding, what if there were more blockchains, etc.
etc.}
\newline

Proof-of-Stake (PoS) systems can accomplish higher throughput than PoW
blockchains. PoS systems are secured by bonded capital as opposed to spent
effort - liquidity opportunity cost vs. burning electricity. The way they work
is by selecting a set of validators with known economic identity who lock up
tokens in exchange for earning the right to "validate" or participate in the
consensus process. If they are found to carry out that process wrongly, they
will be slashed, meaning some or all of the locked tokens will be burned. This
provides a strong disincentive in the direction of misbehavior.
\newline

Since the consensus protocol doesn't revolve around wasting effort, block times
and agreement can occur much faster. Solutions to PoW challenges don't have to
be found before a block can be authored, so the overhead of authoring a block is
reduced to only the costs of creating and distributing the block.
\newline

However, consensus on a PoS chain requires full agreement of 2/3+ of the
validator set for everything that occurs at Layer 1: all logic which is carried
out as part of the blockchain's state machine. This means that everybody still
needs to check everything. Furthermore, validators may have different views of
the system based on the information that they receive over an asynchronous
network, making agreement on the latest state more difficult.
\newline

Parachains are an example of a \textbf{sharded} protocol. Sharding is a concept
borrowed from traditional database architecture. Rather than requiring every
participant to check every transaction, we require each participant to check
some subset of transactions, with enough redundancy baked in that byzantine
(arbitrarily malicious) participants can't sneak in invalid transactions - at
least not without being detected and getting slashed, with those transactions
reverted.
\newline

Sharding and Proof-of-Stake in coordination with each other allow a parachain
host to provide full security on many parachains, even without all participants
checking all state transitions.

\todo{note about network effects \& bridging}

\subsection{Issue 2: Flexibility / Specialization}

"dumb" VMs don't give you the flexibility. Any engineer knows that being able to
specialize on a problem gives them and their users more leverage. \todo{...}
\newline

Having recognized these issues, we set out to find a solution to these problems,
which could allow developers to create and deploy purpose-built blockchains
unified under a common source of security, with the capability of
message-passing between them; a heterogeneous sharding solution, which we have
come to know as \textbf{Parachains}.

\section{Parachains: Basic Functionality}

This section aims to describe, at a high level, the architecture, actors, and
Subsystems involved in the implementation of parachains. It also illuminates
certain subtleties and challenges faced in the design and implementation of
those Subsystems. Our goal is to carry a parachain block from authoring to
secure inclusion, and define a process which can be carried out repeatedly and
in parallel for many different parachains to extend them over time.
Understanding of the high-level approach taken here is important to provide
context for the proposed architecture further on.
\newline

The Parachain Host is a blockchain, known as the relay-chain, and the actors
which provide security and inputs to the blockchain.
\newline

First, it's important to go over the main actors we have involved in the
parachain host.
\newline

\begin{enumerate}
    \item Validators. These nodes are responsible for validating proposed
    parachain blocks. They do so by checking a Proof-of-Validity (PoV) of the
    block and ensuring that the PoV remains available. They put financial
    capital down as "skin in the game" which can be slashed (destroyed) if they
    are proven to have misvalidated.
    \item Collators. These nodes are responsible for creating the
    Proofs-of-Validity that validators know how to check. Creating a PoV
    typically requires familiarity with the transaction format and block
    authoring rules of the parachain, as well as having access to the full state
    of the parachain.
    \item Fishermen. These are user-operated, permissionless nodes whose goal is
    to catch misbehaving validators in exchange for a bounty. Collators and
    validators can behave as Fishermen too. Fishermen aren't necessary for
    security, and aren't covered in-depth by this document.
\end{enumerate}

This alludes to a simple pipeline where collators send validators parachain
blocks and their requisite PoV to check. Then, validators validate the block
using the PoV, signing statements which describe either the positive or negative
outcome, and with enough positive statements, the block can be noted on the
relay-chain. Negative statements are not a veto but will lead to a dispute, with
those on the wrong side being slashed. If another validator later detects that a
validator or group of validators incorrectly signed a statement claiming a block
was valid, then those validators will be slashed, with the checker receiving a
bounty.
\newline

However, there is a problem with this formulation. In order for another
validator to check the previous group of validators' work after the fact, the
PoV must remain available so the other validator can fetch it in order to check
the work. The PoVs are expected to be too large to include in the blockchain
directly, so we require an alternate data availability scheme which requires
validators to prove that the inputs to their work will remain available, and so
their work can be checked. Empirical tests tell us that many PoVs may be between
1 and 10MB during periods of heavy load.
\newline

Here is a description of the Inclusion Pipeline: the path a parachain block (or
parablock, for short) takes from creation to inclusion:
\newline

\begin{enumerate}
    \item Validators are selected and assigned to parachains by the Validator
    Assignment routine.
    \item A collator produces the parachain block, which is known as a parachain
    candidate or candidate, along with a PoV for the candidate.
    \item The collator forwards the candidate and PoV to validators assigned to
    the same parachain via the Collation Distribution Subsystem.
    \item The validators assigned to a parachain at a given point in time
    participate in the Candidate Backing Subsystem to validate candidates that
    were put forward for validation. Candidates which gather enough signed
    validity statements from validators are considered "backable". Their backing
    is the set of signed validity statements.
    \item A relay-chain block author, selected by BABE, can note up to one (1)
    backable candidate for each parachain to include in the relay-chain block
    alongside its backing. A backable candidate once included in the relay-chain
    is considered backed in that fork of the relay-chain.
    \item Once backed in the relay-chain, the parachain candidate is considered
    to be "pending availability". It is not considered to be included as part of
    the parachain until it is proven available.
    \item In the following relay-chain blocks, validators will participate in
    the Availability Distribution Subsystem to ensure availability of the
    candidate. Information regarding the availability of the candidate will be
    noted in the subsequent relay-chain blocks.
    \item Once the relay-chain state machine has enough information to consider
    the candidate's PoV as being available, the candidate is considered to be
    part of the parachain and is graduated to being a full parachain block, or
    parablock for short.
\end{enumerate}

Note that the candidate can fail to be included in any of the following ways:

\begin{itemize}
    \item The collator is not able to propagate the candidate to any validators
    assigned to the parachain.
    \item The candidate is not backed by validators participating in the
    Candidate Backing Subsystem.
    \item The candidate is not selected by a relay-chain block author to be
    included in the relay chain.
    \item The candidate's PoV is not considered as available within a timeout
    and is discarded from the relay chain.
\end{itemize}

This process can be divided further down. Steps 2 \& 3 relate to the work of the
collator in collating and distributing the candidate to validators via the
Collation Distribution Subsystem. Steps 3 \& 4 relate to the work of the
validators in the Candidate Backing Subsystem and the block author (itself a
validator) to include the block into the relay chain. Steps 6, 7, and 8
correspond to the logic of the relay-chain state-machine (otherwise known as the
Runtime) used to fully incorporate the block into the chain. Step 7 requires
further work on the validators' parts to participate in the Availability
Distribution Subsystem and include that information into the relay chain for
step 8 to be fully realized.
\newline

This brings us to the second part of the process. Once a parablock is considered
available and part of the parachain, it is still "pending approval". At this
stage in the pipeline, the parablock has been backed by a majority of validators
in the group assigned to that parachain, and its data has been guaranteed
available by the set of validators as a whole. Once it's considered available,
the host will even begin to accept children of that block. At this point, we can
consider the parablock as having been tentatively included in the parachain,
although more confirmations are desired. However, the validators in the
parachain-group (known as the "Parachain Validators" for that parachain) are
sampled from a validator set which contains some proportion of byzantine, or
arbitrarily malicious members. This implies that the Parachain Validators for
some parachain may be majority-dishonest, which means that secondary checks must
be done on the block before it can be considered approved. This is necessary
only because the Parachain Validators for a given parachain are sampled from an
overall validator set which is assumed to be up to <1/3 dishonest - meaning that
there is a chance to randomly sample Parachain Validators for a parachain that
are majority or fully dishonest and can back a candidate wrongly. The Approval
Process allows us to detect such misbehavior after-the-fact without allocating
more Parachain Validators and reducing the throughput of the system. A
parablock's failure to pass the approval process will invalidate the block as
well as all of its descendents. However, only the validators who backed the
block in question will be slashed, not the validators who backed the
descendents.
\newline

The Approval Process looks like this:

\begin{enumerate}
    \item Parablocks that have been included by the Inclusion Pipeline are
    pending approval for a time-window known as the secondary checking window.
    \item During the secondary-checking window, validators randomly self-select
    to perform secondary checks on the parablock.
    \item These validators, known in this context as secondary checkers, acquire
    the parablock and its PoV, and re-run the validation function.
    \item The secondary checkers submit the result of their checks to the relay
    chain. Contradictory results lead to escalation, where even more secondary
    checkers are selected and the secondary-checking window is extended.
    \item At the end of the Approval Process, the parablock is either Approved
    or it is rejected. More on the rejection process later.
\end{enumerate}

These two pipelines sum up the sequence of events necessary to extend and
acquire full security on a Parablock. Note that the Inclusion Pipeline must
conclude for a specific parachain before a new block can be accepted on that
parachain. After inclusion, the Approval Process kicks off, and can be running
for many parachain blocks at once.
\newline

Reiterating the lifecycle of a candidate:

\begin{enumerate}
    \item Candidate: put forward by a collator to a validator.
    \item Seconded: put forward by a validator to other validators.
    \item Backable: validity attested to by a majority of assigned validators.
    \item Backed: Backable \& noted in a fork of the relay-chain.
    \item Pending availability: Backed but not yet considered available.
    \item Included: Backed and considered available.
    \item Accepted: Backed, available, and undisputed
\end{enumerate}

\todo{Diagram: Inclusion Pipeline \& Approval Subsystems interaction}

It is also important to take note of the fact that the relay-chain is extended
by BABE, which is a forkful algorithm. That means that different block authors
can be chosen at the same time, and may not be building on the same block
parent. Furthermore, the set of validators is not fixed, nor is the set of
parachains. And even with the same set of validators and parachains, the
validators' assignments to parachains is flexible. This means that the
architecture proposed in the next chapters must deal with the variability and
multiplicity of the network state.

\begin{verbnobox}[\small]
....... Validator Group 1 ..........
.                                  .
.         (Validator 4)            .
.  (Validator 1) (Validator 2)     .
.         (Validator 5)            .
.                                  .
..........Building on C  ...........        ........ Validator Group 2 ...........
        +----------------------+           .                                    .
        |    Relay Block C     |           .           (Validator 7)            .
        +----------------------+           .    ( Validator 3) (Validator 6)    .
                        \                  .                                    .
                         \                 ......... Building on B  .............
                          \
                    +----------------------+
                    |  Relay Block B       |
                    +----------------------+
                                |
                    +----------------------+
                    |  Relay Block A       |
                    +----------------------+
\end{verbnobox}

In this example, group 1 has received block C while the others have not due to
network asynchrony. Now, a validator from group 2 may be able to build another
block on top of B, called C'. Assume that afterwards, some validators become
aware of both C and C', while others remain only aware of one.

\begin{verbnobox}[\small]
....... Validator Group 1 ..........      ........ Validator Group 2 ...........
.                                  .      .                                    .
.  (Validator 4) (Validator 1)     .      .    (Validator 7) (Validator 6)     .
.                                  .      .                                    .
.......... Building on C  ..........      ......... Building on C' .............


....... Validator Group 3 ..........
.                                  .
.   (Validator 2) (Validator 3)    .
.        (Validator 5)             .
.                                  .
....... Building on C and C' .......

        +----------------------+         +----------------------+
        |    Relay Block C     |         |    Relay Block C'    |
        +----------------------+         +----------------------+
                         \                 /
                          \               /
                           \             /
                    +----------------------+
                    |  Relay Block B       |
                    +----------------------+
                                |
                    +----------------------+
                    |  Relay Block A       |
                    +----------------------+
\end{verbnobox}

\textbf{Those validators that are aware of many competing heads must be aware of the
work happening on each one. They may contribute to some or a full extent on
both. It is possible that due to network asynchrony two forks may grow in
parallel for some time, although in the absence of an adversarial network this
is unlikely in the case where there are validators who are aware of both chain
heads.}

\section{Architecture}

Our Parachain Host includes a blockchain known as the relay-chain. A blockchain
is a Directed Acyclic Graph (DAG) of state transitions, where every block can be
considered to be the head of a linked-list (known as a "chain" or "fork") with a
cumulative state which is determined by applying the state transition of each
block in turn. All paths through the DAG terminate at the Genesis Block. In
fact, the blockchain is a tree, since each block can have only one parent.

\begin{verbnobox}[\small]
+----------------+     +----------------+
|    Block 4     |     | Block 5        |
+----------------+     +----------------+
               \           /
                V         V
            +---------------+
            |    Block 3    |
            +---------------+
                    |
                    V
            +----------------+     +----------------+
            |    Block 1     |     |   Block 2      |
            +----------------+     +----------------+
                       \            /
                        V          V
                    +----------------+
                    |    Genesis     |
                    +----------------+
\end{verbnobox}

A blockchain network is comprised of nodes. These nodes each have a view of many
different forks of a blockchain and must decide which forks to follow and what
actions to take based on the forks of the chain that they are aware of.
\newline

So in specifying an architecture to carry out the functionality of a Parachain
Host, we have to answer two categories of questions:

\begin{enumerate}
    \item What is the state-transition function of the blockchain? What is
    necessary for a transition to be considered valid, and what information is
    carried within the implicit state of a block?
    \item Being aware of various forks of the blockchain as well as global
    private state such as a view of the current time, what behaviors should a
    node undertake? What information should a node extract from the state of
    which forks, and how should that information be used?
\end{enumerate}

The first category of questions will be addressed by the Runtime, which defines
the state-transition logic of the chain. Runtime logic only has to focus on the
perspective of one chain, as each state has only a single parent state.
\newline

The second category of questions addressed by Node-side behavior. Node-side
behavior defines all activities that a node undertakes, given its view of the
blockchain/block-DAG. Node-side behavior can take into account all or many of
the forks of the blockchain, and only conditionally undertake certain activities
based on which forks it is aware of, as well as the state of the head of those
forks.

\begin{verbnobox}[\small]
     __________________________________
    /                                  \
    |            Runtime               |
    |                                  |
    \_________(Runtime API )___________/
                |       ^
                V       |
+----------------------------------------------+
|                                              |
|                   Node                       |
|                                              |
|                                              |
+----------------------------------------------+
                    +  +
                    |  |
--------------------+  +------------------------
                    Transport
------------------------------------------------
\end{verbnobox}

It is also helpful to divide Node-side behavior into two further categories:
Networking and Core. Networking behaviors relate to how information is
distributed between nodes. Core behaviors relate to internal work that a
specific node does. These two categories of behavior often interact, but can be
heavily abstracted from each other. Core behaviors care that information is
distributed and received, but not the internal details of how distribution and
receipt function. Networking behaviors act on requests for distribution or
fetching of information, but are not concerned with how the information is used
afterwards. This allows us to create clean boundaries between Core and
Networking activities, improving the modularity of the code.

\begin{verbnobox}
 ___________________                    ____________________
/       Core        \                  /     Networking     \
|                   |  Send "Hello"    |                    |
|                   |-  to "foo"   --->|                    |
|                   |                  |                    |
|                   |                  |                    |
|                   |                  |                    |
|                   |    Got "World"   |                    |
|                   |<--  from "bar" --|                    |
|                   |                  |                    |
\___________________/                  \____________________/
                                        ______| |______
                                        ___Transport___
\end{verbnobox}

Node-side behavior is split up into various subsystems. Subsystems are
long-lived workers that perform a particular category of work. Subsystems can
communicate with each other, and do so via an Overseer that prevents race
conditions.
\newline

Runtime logic is divided up into Modules and APIs. Modules encapsulate
particular behavior of the system. Modules consist of storage, routines, and
entry-points. Routines are invoked by entry points, by other modules, upon block
initialization or closing. Routines can read and alter the storage of the
module. Entry-points are the means by which new information is introduced to a
module and can limit the origins (user, root, parachain) that they accept being
called by. Each block in the blockchain contains a set of Extrinsics. Each
extrinsic targets a a specific entry point to trigger and which data should be
passed to it. Runtime APIs provide a means for Node-side behavior to extract
meaningful information from the state of a single fork.
\newline

These two aspects of the implementation are heavily dependent on each other. The
Runtime depends on Node-side behavior to author blocks, and to include
Extrinsics which trigger the correct entry points. The Node-side behavior relies
on Runtime APIs to extract information necessary to determine which actions to
take.

\section{Architecture: Runtime}

\subsection{Broad Strokes}

It's clear that we want to separate different aspects of the runtime logic into different modules. Modules define their own storage, routines, and entry-points. They also define initialization and finalization logic.

Due to the (lack of) guarantees provided by a particular blockchain-runtime framework, there is no defined or dependable order in which modules' initialization or finalization logic will run. Supporting this blockchain-runtime framework is important enough to include that same uncertainty in our model of runtime modules in this guide. Furthermore, initialization logic of modules can trigger the entry-points or routines of other modules. This is one architectural pressure against dividing the runtime logic into multiple modules. However, in this case the benefits of splitting things up outweigh the costs, provided that we take certain precautions against initialization and entry-point races.

We also expect, although it's beyond the scope of this guide, that these runtime modules will exist alongside various other modules. This has two facets to consider. First, even if the modules that we describe here don't invoke each others' entry points or routines during initialization, we still have to protect against those other modules doing that. Second, some of those modules are expected to provide governance capabilities for the chain. Configuration exposed by parachain-host modules is mostly for the benefit of these governance modules, to allow the operators or community of the chain to tweak parameters.

The runtime's primary roles to manage scheduling and updating of parachains and parathreads, as well as handling misbehavior reports and slashing. This guide doesn't focus on how parachains or parathreads are registered, only that they are. Also, this runtime description assumes that validator sets are selected somehow, but doesn't assume any other details than a periodic session change event. Session changes give information about the incoming validator set and the validator set of the following session.

The runtime also serves another role, which is to make data available to the Node-side logic via Runtime APIs. These Runtime APIs should be sufficient for the Node-side code to author blocks correctly.

There is some functionality of the relay chain relating to parachains that we also consider beyond the scope of this document. In particular, all modules related to how parachains are registered aren't part of this guide, although we do provide routines that should be called by the registration process.

We will split the logic of the runtime up into these modules:

\begin{itemize}
    \item Initializer: manage initialization order of the other modules.
    \item Configuration: manage configuration and configuration updates in a non-racy manner.
    \item Paras: manage chain-head and validation code for parachains and parathreads.
    \item Scheduler: manages parachain and parathread scheduling as well as validator assignments.
    \item Inclusion: handles the inclusion and availability of scheduled parachains and parathreads.
    \item Validity: handles secondary checks and dispute resolution for included, available parablocks.
\end{itemize}

The Initializer module is special - it's responsible for handling the initialization logic of the other modules to ensure that the correct initialization order and related invariants are maintained. The other modules won't specify a on-initialize logic, but will instead expose a special semi-private routine that the initialization module will call. The other modules are relatively straightforward and perform the roles described above.

The Parachain Host operates under a changing set of validators. Time is split up into periodic sessions, where each session brings a potentially new set of validators. Sessions are buffered by one, meaning that the validators of the upcoming session are fixed and always known. Parachain Host runtime modules need to react to changes in the validator set, as it will affect the runtime logic for processing candidate backing, availability bitfields, and misbehavior reports. The Parachain Host modules can't determine ahead-of-time exactly when session change notifications are going to happen within the block (note: this depends on module initialization order again - better to put session before parachains modules). Ideally, session changes are always handled before initialization. It is clearly a problem if we compute validator assignments to parachains during initialization and then the set of validators changes. In the best case, we can recognize that re-initialization needs to be done. In the worst case, bugs would occur.

There are 3 main ways that we can handle this issue:

\begin{enumerate}
    \item Establish an invariant that session change notifications always happen after initialization. This means that when we receive a session change notification before initialization, we call the initialization routines before handling the session change.
    \item Require that session change notifications always occur before initialization. Brick the chain if session change notifications ever happen after initialization.
    \item Handle both the before and after cases.
\end{enumerate}

Although option 3 is the most comprehensive, it runs counter to our goal of simplicity. Option 1 means requiring the runtime to do redundant work at all sessions and will also mean, like option 3, that designing things in such a way that initialization can be rolled back and reapplied under the new environment. That leaves option 2, although it is a "nuclear" option in a way and requires us to constrain the parachain host to only run in full runtimes with a certain order of operations.

So the other role of the initializer module is to forward session change notifications to modules in the initialization order, throwing an unrecoverable error if the notification is received after initialization. Session change is the point at which the configuration module updates the configuration. Most of the other modules will handle changes in the configuration during their session change operation, so the initializer should provide both the old and new configuration to all the other modules alongside the session change notification. This means that a session change notification should consist of the following data:

\begin{verbnobox}[\small]
struct SessionChangeNotification {
	// The new validators in the session.
	validators: Vec<ValidatorId>,
	// The validators for the next session.
	queued: Vec<ValidatorId>,
	// The configuration before handling the session change.
	prev_config: HostConfiguration,
	// The configuration after handling the session change.
	new_config: HostConfiguration,
	// A secure randomn seed for the session, gathered from BABE.
	random_seed: [u8; 32],
}
\end{verbnobox}

\todo{REVIEW: other options? arguments in favor of going for options 1 or 3 instead of 2. we could do a "soft" version of 2 where we note that the chain is potentially broken due to bad initialization order}
\todo{TODO Diagram: order of runtime operations (initialization, session change)}

