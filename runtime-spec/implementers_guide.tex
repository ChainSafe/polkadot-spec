\chapter{Implementer's Guide}

\section{Ramble / Preamble}

This document aims to describe the purpose, functionality, and implementation of
a host for Polkadot's parachains. It is not for the implementor of a specific
parachain but rather for the implementor of the Parachain Host, which provides
security and advancement for constituent parachains. In practice, this is for
the implementors of Polkadot.
\newline

There are a number of other documents describing the research in more detail.
All referenced documents will be linked here and should be read alongside this
document for the best understanding of the full picture. However, this is the
only document which aims to describe key aspects of Polkadot's particular
instantiation of much of that research down to low-level technical details and
software architecture.

\section{Origins}

Parachains are the solution to a problem. As with any solution, it cannot be
understood without first understanding the problem. So let's start by going over
the issues faced by blockchain technology that led to us beginning to explore
the design space for something like parachains.

\subsection{Issue 1: Scalability}

It became clear a few years ago that the transaction throughput of simple
Proof-of-Work (PoW) blockchains such as Bitcoin, Ethereum, and myriad others was
simply too low. \todo{PoS, sharding, what if there were more blockchains, etc.
etc.}
\newline

Proof-of-Stake (PoS) systems can accomplish higher throughput than PoW
blockchains. PoS systems are secured by bonded capital as opposed to spent
effort - liquidity opportunity cost vs. burning electricity. The way they work
is by selecting a set of validators with known economic identity who lock up
tokens in exchange for earning the right to "validate" or participate in the
consensus process. If they are found to carry out that process wrongly, they
will be slashed, meaning some or all of the locked tokens will be burned. This
provides a strong disincentive in the direction of misbehavior.
\newline

Since the consensus protocol doesn't revolve around wasting effort, block times
and agreement can occur much faster. Solutions to PoW challenges don't have to
be found before a block can be authored, so the overhead of authoring a block is
reduced to only the costs of creating and distributing the block.
\newline

However, consensus on a PoS chain requires full agreement of 2/3+ of the
validator set for everything that occurs at Layer 1: all logic which is carried
out as part of the blockchain's state machine. This means that everybody still
needs to check everything. Furthermore, validators may have different views of
the system based on the information that they receive over an asynchronous
network, making agreement on the latest state more difficult.
\newline

Parachains are an example of a \textbf{sharded} protocol. Sharding is a concept
borrowed from traditional database architecture. Rather than requiring every
participant to check every transaction, we require each participant to check
some subset of transactions, with enough redundancy baked in that byzantine
(arbitrarily malicious) participants can't sneak in invalid transactions - at
least not without being detected and getting slashed, with those transactions
reverted.
\newline

Sharding and Proof-of-Stake in coordination with each other allow a parachain
host to provide full security on many parachains, even without all participants
checking all state transitions.

\todo{note about network effects \& bridging}

\subsection{Issue 2: Flexibility / Specialization}

"dumb" VMs don't give you the flexibility. Any engineer knows that being able to
specialize on a problem gives them and their users more leverage. \todo{...}
\newline

Having recognized these issues, we set out to find a solution to these problems,
which could allow developers to create and deploy purpose-built blockchains
unified under a common source of security, with the capability of
message-passing between them; a heterogeneous sharding solution, which we have
come to know as \textbf{Parachains}.

\section{Parachains: Basic Functionality}

This section aims to describe, at a high level, the architecture, actors, and
Subsystems involved in the implementation of parachains. It also illuminates
certain subtleties and challenges faced in the design and implementation of
those Subsystems. Our goal is to carry a parachain block from authoring to
secure inclusion, and define a process which can be carried out repeatedly and
in parallel for many different parachains to extend them over time.
Understanding of the high-level approach taken here is important to provide
context for the proposed architecture further on.
\newline

The Parachain Host is a blockchain, known as the relay-chain, and the actors
which provide security and inputs to the blockchain.
\newline

First, it's important to go over the main actors we have involved in the
parachain host.
\newline

\begin{enumerate}
    \item Validators. These nodes are responsible for validating proposed
    parachain blocks. They do so by checking a Proof-of-Validity (PoV) of the
    block and ensuring that the PoV remains available. They put financial
    capital down as "skin in the game" which can be slashed (destroyed) if they
    are proven to have misvalidated.
    \item Collators. These nodes are responsible for creating the
    Proofs-of-Validity that validators know how to check. Creating a PoV
    typically requires familiarity with the transaction format and block
    authoring rules of the parachain, as well as having access to the full state
    of the parachain.
    \item Fishermen. These are user-operated, permissionless nodes whose goal is
    to catch misbehaving validators in exchange for a bounty. Collators and
    validators can behave as Fishermen too. Fishermen aren't necessary for
    security, and aren't covered in-depth by this document.
\end{enumerate}

This alludes to a simple pipeline where collators send validators parachain
blocks and their requisite PoV to check. Then, validators validate the block
using the PoV, signing statements which describe either the positive or negative
outcome, and with enough positive statements, the block can be noted on the
relay-chain. Negative statements are not a veto but will lead to a dispute, with
those on the wrong side being slashed. If another validator later detects that a
validator or group of validators incorrectly signed a statement claiming a block
was valid, then those validators will be slashed, with the checker receiving a
bounty.
\newline

However, there is a problem with this formulation. In order for another
validator to check the previous group of validators' work after the fact, the
PoV must remain available so the other validator can fetch it in order to check
the work. The PoVs are expected to be too large to include in the blockchain
directly, so we require an alternate data availability scheme which requires
validators to prove that the inputs to their work will remain available, and so
their work can be checked. Empirical tests tell us that many PoVs may be between
1 and 10MB during periods of heavy load.
\newline

Here is a description of the Inclusion Pipeline: the path a parachain block (or
parablock, for short) takes from creation to inclusion:
\newline

\begin{enumerate}
    \item Validators are selected and assigned to parachains by the Validator
    Assignment routine.
    \item A collator produces the parachain block, which is known as a parachain
    candidate or candidate, along with a PoV for the candidate.
    \item The collator forwards the candidate and PoV to validators assigned to
    the same parachain via the Collation Distribution Subsystem.
    \item The validators assigned to a parachain at a given point in time
    participate in the Candidate Backing Subsystem to validate candidates that
    were put forward for validation. Candidates which gather enough signed
    validity statements from validators are considered "backable". Their backing
    is the set of signed validity statements.
    \item A relay-chain block author, selected by BABE, can note up to one (1)
    backable candidate for each parachain to include in the relay-chain block
    alongside its backing. A backable candidate once included in the relay-chain
    is considered backed in that fork of the relay-chain.
    \item Once backed in the relay-chain, the parachain candidate is considered
    to be "pending availability". It is not considered to be included as part of
    the parachain until it is proven available.
    \item In the following relay-chain blocks, validators will participate in
    the Availability Distribution Subsystem to ensure availability of the
    candidate. Information regarding the availability of the candidate will be
    noted in the subsequent relay-chain blocks.
    \item Once the relay-chain state machine has enough information to consider
    the candidate's PoV as being available, the candidate is considered to be
    part of the parachain and is graduated to being a full parachain block, or
    parablock for short.
\end{enumerate}

Note that the candidate can fail to be included in any of the following ways:

\begin{itemize}
    \item The collator is not able to propagate the candidate to any validators
    assigned to the parachain.
    \item The candidate is not backed by validators participating in the
    Candidate Backing Subsystem.
    \item The candidate is not selected by a relay-chain block author to be
    included in the relay chain.
    \item The candidate's PoV is not considered as available within a timeout
    and is discarded from the relay chain.
\end{itemize}

This process can be divided further down. Steps 2 \& 3 relate to the work of the
collator in collating and distributing the candidate to validators via the
Collation Distribution Subsystem. Steps 3 \& 4 relate to the work of the
validators in the Candidate Backing Subsystem and the block author (itself a
validator) to include the block into the relay chain. Steps 6, 7, and 8
correspond to the logic of the relay-chain state-machine (otherwise known as the
Runtime) used to fully incorporate the block into the chain. Step 7 requires
further work on the validators' parts to participate in the Availability
Distribution Subsystem and include that information into the relay chain for
step 8 to be fully realized.
\newline

This brings us to the second part of the process. Once a parablock is considered
available and part of the parachain, it is still "pending approval". At this
stage in the pipeline, the parablock has been backed by a majority of validators
in the group assigned to that parachain, and its data has been guaranteed
available by the set of validators as a whole. Once it's considered available,
the host will even begin to accept children of that block. At this point, we can
consider the parablock as having been tentatively included in the parachain,
although more confirmations are desired. However, the validators in the
parachain-group (known as the "Parachain Validators" for that parachain) are
sampled from a validator set which contains some proportion of byzantine, or
arbitrarily malicious members. This implies that the Parachain Validators for
some parachain may be majority-dishonest, which means that secondary checks must
be done on the block before it can be considered approved. This is necessary
only because the Parachain Validators for a given parachain are sampled from an
overall validator set which is assumed to be up to <1/3 dishonest - meaning that
there is a chance to randomly sample Parachain Validators for a parachain that
are majority or fully dishonest and can back a candidate wrongly. The Approval
Process allows us to detect such misbehavior after-the-fact without allocating
more Parachain Validators and reducing the throughput of the system. A
parablock's failure to pass the approval process will invalidate the block as
well as all of its descendents. However, only the validators who backed the
block in question will be slashed, not the validators who backed the
descendents.
\newline

The Approval Process looks like this:

\begin{enumerate}
    \item Parablocks that have been included by the Inclusion Pipeline are
    pending approval for a time-window known as the secondary checking window.
    \item During the secondary-checking window, validators randomly self-select
    to perform secondary checks on the parablock.
    \item These validators, known in this context as secondary checkers, acquire
    the parablock and its PoV, and re-run the validation function.
    \item The secondary checkers submit the result of their checks to the relay
    chain. Contradictory results lead to escalation, where even more secondary
    checkers are selected and the secondary-checking window is extended.
    \item At the end of the Approval Process, the parablock is either Approved
    or it is rejected. More on the rejection process later.
\end{enumerate}

These two pipelines sum up the sequence of events necessary to extend and
acquire full security on a Parablock. Note that the Inclusion Pipeline must
conclude for a specific parachain before a new block can be accepted on that
parachain. After inclusion, the Approval Process kicks off, and can be running
for many parachain blocks at once.
\newline

Reiterating the lifecycle of a candidate:

\begin{enumerate}
    \item Candidate: put forward by a collator to a validator.
    \item Seconded: put forward by a validator to other validators.
    \item Backable: validity attested to by a majority of assigned validators.
    \item Backed: Backable \& noted in a fork of the relay-chain.
    \item Pending availability: Backed but not yet considered available.
    \item Included: Backed and considered available.
    \item Accepted: Backed, available, and undisputed
\end{enumerate}

\todo{Diagram: Inclusion Pipeline \& Approval Subsystems interaction}

It is also important to take note of the fact that the relay-chain is extended
by BABE, which is a forkful algorithm. That means that different block authors
can be chosen at the same time, and may not be building on the same block
parent. Furthermore, the set of validators is not fixed, nor is the set of
parachains. And even with the same set of validators and parachains, the
validators' assignments to parachains is flexible. This means that the
architecture proposed in the next chapters must deal with the variability and
multiplicity of the network state.

\begin{verbnobox}[\small]
....... Validator Group 1 ..........
.                                  .
.         (Validator 4)            .
.  (Validator 1) (Validator 2)     .
.         (Validator 5)            .
.                                  .
..........Building on C  ...........        ........ Validator Group 2 ...........
        +----------------------+           .                                    .
        |    Relay Block C     |           .           (Validator 7)            .
        +----------------------+           .    ( Validator 3) (Validator 6)    .
                        \                  .                                    .
                         \                 ......... Building on B  .............
                          \
                    +----------------------+
                    |  Relay Block B       |
                    +----------------------+
                                |
                    +----------------------+
                    |  Relay Block A       |
                    +----------------------+
\end{verbnobox}

In this example, group 1 has received block C while the others have not due to
network asynchrony. Now, a validator from group 2 may be able to build another
block on top of B, called C'. Assume that afterwards, some validators become
aware of both C and C', while others remain only aware of one.

\begin{verbnobox}[\small]
....... Validator Group 1 ..........      ........ Validator Group 2 ...........
.                                  .      .                                    .
.  (Validator 4) (Validator 1)     .      .    (Validator 7) (Validator 6)     .
.                                  .      .                                    .
.......... Building on C  ..........      ......... Building on C' .............


....... Validator Group 3 ..........
.                                  .
.   (Validator 2) (Validator 3)    .
.        (Validator 5)             .
.                                  .
....... Building on C and C' .......

        +----------------------+         +----------------------+
        |    Relay Block C     |         |    Relay Block C'    |
        +----------------------+         +----------------------+
                         \                 /
                          \               /
                           \             /
                    +----------------------+
                    |  Relay Block B       |
                    +----------------------+
                                |
                    +----------------------+
                    |  Relay Block A       |
                    +----------------------+
\end{verbnobox}

\textbf{Those validators that are aware of many competing heads must be aware of the
work happening on each one. They may contribute to some or a full extent on
both. It is possible that due to network asynchrony two forks may grow in
parallel for some time, although in the absence of an adversarial network this
is unlikely in the case where there are validators who are aware of both chain
heads.}

