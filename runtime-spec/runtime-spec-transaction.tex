\newpage
\chapter{Extrinsics}

\section{Introduction}

An extrinsic is a SCALE encoded array consisting of a version number,
signature, and varying data types indicating the resulting Runtime function to
be called, including the parameters required for that function to be executed.
\newline

\[
    tx := (T_v, T_b)
\]

Type $T_b$ varies for each version and is specified in the corresponding
section.

\subsection{Preliminaries}

\begin{definition}
    \label{defn-extrinsic-version}
    $T_v$ defines the extrinsic version. The Runtime handles extrinsics and
    its validity differently based on the version, where the extrinsic format
    of each version is dictated by the Runtime. This allows Polkadot to evolve
    with new and more advanced extrinsic formats, while still being able to
    correctly execute older formats.
    \newline

    $T_v$ does not consist of the version number directly, rather the version
    number is manipulated with bitwise operators in order to indicate whether
    the extrinsic is signed ("transaction") or unsigned ("inherent").
    \newline

    If the extrinsic is \textbf{signed}, and therefore a transaction, $T_v$ is
    defined as:

    \[
        T_v := n \ | \ 1000 \ 0000
    \]

    where $n$ is the version number and $|$ implies a bitwise OR operator.
    \newline
    \newpage

    If the extrinsic is \textbf{unsigned}, and therefore an inherent, $T_v$ is
    defined as:

    \[
        T_v := n \ \& \ 0111 \ 1111
    \]

    where $n$ is the version number and $\&$ implies a bitwise AND operator.
    \newline

    As an example, for extrinsic format version 4, an signed extrinsic
    represents $T_v$ as \verb|132| while a unsigned extrinsic represents it as
    \verb|4|.
\end{definition}

\subsection{Version 4}

Version 4 of the Polkadot extrinsic format is defined as follows:

\[
    T_b := (A_i, Sig, E, M_i, F_i(m))
\]

where each values represents:
\begin{itemize}
    \item $A_i$: the 32-byte address of the sender (Def. \ref{defn-extrinsic-address}).
    \item $Sig$: the signature of the sender (Def. \ref{defn-extrinsic-signature}).
    \item $E$: the extra data for the extrinsic (Def. \ref{defn-extra-data}).
    \item $M_i$: the indicator of the Polkadot module (Def. \ref{defn-module-indicator}).
    \item $F_i(m)$: the indicator of the function of the Polkadot module (Def. \ref{defn-function-indicator}).
\end{itemize}

\begin{definition}
    \label{defn-extrinsic-address}
    Account Id, $A_i$, is the 32-byte address of the sender of the extrinsic as
    described in the
    \href{https://github.com/paritytech/substrate/wiki/External-Address-Format-(SS58)}{external
    SS58 address format}.
\end{definition}

\begin{definition}
    \label{defn-extrinsic-signature}
    The signature, $Sig$, is a varying data type indicating the used signature
    type, followed by the signature created by the extrinsic author. The
    following types are supported:

    \[
        Sig :=
        \begin{cases}
        0, & \text{Ed25519, followed by: } (b_0, ...,b_{63}) \\
        1, & \text{Sr25519, followed by: } (b_0, ...,b_{63}) \\
        2, & \text{Ecdsa, followed by: } (b_0, ...,b_{64})
        \end{cases}
    \]

    \todo{@fabio: clarify whether Polkadot actually allows different signature types}.
    \newline

    Signature types vary in sizes, but each individual type is always fixed-size
    and therefore does not contain a length prefix as specified by the SCALE
    codec. \verb|Ed25519| and \verb|Sr25519| signatures are 512-bit while
    \verb|Ecdsa| is 560-bit, where the last 8 bits are the recovery ID.
    \newline

    The signature is created by signing payload $P$.

    \begin{equation}
        \begin{aligned}
        P &:= \begin{cases}
            Raw, & \text{if } |Raw| \leq 256\\
            Blake2(Raw), & \text{if } |Raw| > 256\\
        \end{cases}\\
        Raw &:= (M_i, F_i(m), E, R_v, T_v, H_h(G), H_h(B))\\
        \end{aligned}
    \end{equation}

    where each value represents:
    \begin{itemize}
        \item $M_i$: the module indicator (Def. \ref{defn-module-indicator}).
        \item $F_i(m)$: the function indicator of the module
        (Def. \ref{defn-function-indicator}).
        \item $E$: the extra data (Def. \ref{defn-extra-data}).
        \item $R_v$: a UINT32 containing the specification version of \verb|14|.
        \item $T_v$: a UINT32 containing the extrinsic version.
        \todo{@fabio: the source code seems to specify two types of extrinsic versions, one in Polkadot and one in Substrate... clarify}.
        \item $H_h(G)$: a 32-byte array containing the genesis hash.
        \item $H_h(B)$: a 32-byte array containing the hash of the block which
        starts the mortality period, as described in Definition
        \ref{defn-extrinsic-mortality}.
    \end{itemize}
\end{definition}

\begin{definition}
    \label{defn-extra-data}
    Extra data, $E$, is a tuple containing additional meta data about the
    extrinsic and the system it is meant to be executed in.

    \[
        E := (M, N, P_t)
    \]

    where each value represents:
    \begin{itemize}
        \item $M$: contains the mortality of the extrinsic (Def. \ref{defn-extrinsic-mortality}).
        \item $N$: a compact integer containing the nonce of the sender. The
        nonce must be incremented by one for each extrinsic created, otherwise
        the Polkadot network will reject the extrinsic.
        \item $P_t$: a compact integer containing the transactor pay including tip.
    \end{itemize}

\end{definition}

\begin{definition}
    \label{defn-extrinsic-mortality}
    The \textbf{mortality}, $M$, specifies for how long an extrinsic is considered to
    be valid for inclusion into the block. $M$ is a UINT32 consisting of two concatenated
    UINT16 sub-components.

    \[
        M := M_{per} | M_{pha}
    \]

    where each value represents:

    \begin{itemize}
        \item $M_{per}$: the period of validity from the block hash
        specified as $H_h(B)$ in Definition \ref{defn-extrinsic-signature}.
        \item $M_{pha}$: the phase in the period that this extrinsic's lifetime begins.
    \end{itemize}

    If $M$ is equal to zero, then the extrinsic is considered immortal and can
    be included at any time.
    \newline

    \todo{@fabio: WIP, waiting for clarification from Parity}
\end{definition}

\begin{definition}
    \label{defn-module-indicator}
    $M_i$ is an indicator for the Runtime to which Polkadot \textit{module},
    $m$, the extrinsic should be forwarded to.
    \newline

    $M_i$ is a varying data type pointing to every module exposed to the
    network.

    \[
    M_i :=
    \begin{cases}
    0, & \text{System} \\
    1, & \text{Utility} \\
    ... & \\
    7, & \text{Balances} \\
    ... &
    \end{cases}
    \]
\end{definition}

\begin{definition}
    \label{defn-function-indicator}
    $F_i(m)$ is a tuple which contains an indicator, $m_i$, for the Runtime to
    which \textit{function} within the Polkadot \textit{module}, $m$, the
    extrinsic should be forwarded to. This indicator is followed by the
    concatenated and SCALE encoded parameters of the corresponding function,
    $params$.

    \[
        F_i(m) := (m_i, params)
    \]

    The value of $m_i$ varies for each Polkadot module, since every module
    offers different functions. As an example, the \verb|Balances| module has
    the following functions:

    \[
        Balances_i :=
        \begin{cases}
        0, & \text{transfer} \\
        1, & \text{set\_balance} \\
        2 & \text{force\_transfer} \\
        3 & \text{transfer\_keep\_alive} \\
        \end{cases}
    \]
\end{definition}
