\newpage
\section{Extrinsics}

An extrinsic is a SCALE encoded array consisting of a version number,
signature, and varying data types indicating the resulting Runtime function to
be called, including the parameters required for that function to be executed.
\newline

\[
    tx := (T_v, P)
\]

Type $P$ is different for each version.

\subsection{Preliminaries}

\begin{definition}
    \label{defn-extrinsic-version}
    $T_v$ defines the extrinsic version. The Runtime handles extrinsics and
    its validity differently based on the version, where the extrinsic format
    of each version is dictated by the Runtime. This allows Polkadot to evolve
    with new and more advanced extrinsic formats, while still being able to
    correctly execute older formats.
    \newline

    $T_v$ does not consist of the version number directly, rather the version
    number is manipulated with bitwise operators in order to indicate whether
    the extrinsic is signed ("transaction") or unsigned ("inherent").
    \newline

    If the extrinsic is \textbf{signed}, and therefore a transaction, $T_v$ is
    defined as:

    \[
        T_v := n \ | \ 1000 \ 0000
    \]

    where $n$ is the version number and $|$ implies a bitwise OR operator.
    \newline

    If the extrinsic is \textbf{unsigned}, and therefore an inherent, $T_v$ is
    defined as:

    \[
        T_v := n \ \& \ 0111 \ 1111
    \]

    where $n$ is the version number and $\&$ implies a bitwise AND operator.
    \newline

    As an example, for extrinsic format version 4, an signed extrinsic
    represents $T_v$ as \verb|132| while a unsigned extrinsic represents it as
    \verb|4|.
\end{definition}

\subsection{Version 4}

Version 4 of the Polkadot extrinsic format is defined as follows:

\[
    P := A_i, Sig, E, M_i, F_i(m)
\]

\begin{definition}
    Account Id, $A_i$, is an opaque 256-bit identifier for the sender of the
    extrinsic.
    \todo{@fabio: clarify how a valid/invalid Id is determined}
\end{definition}

\begin{definition}
    The signature, $Sig$, is a varying data type indicating support for three
    different signature types, followed by the signature itself:

    \[
        Sig :=
        \begin{cases}
        0, & \text{Ed25519, followed by: } (b_0, ...,b_{63}) \\
        1, & \text{Sr25519, followed by: } (b_0, ...,b_{63}) \\
        2, & \text{Ecdsa, followed by: } (b_0, ...,b_{64})
        \end{cases}
    \]

    Signature types vary in sizes, but each individual type is always fixed-size
    and therefore does not contain a length prefix as specified by the SCALE
    codec. \verb|Ed25519| and \verb|Sr25519| signatures are 512-bit while
    \verb|Ecdsa| is 560-bit, where the last 8 bits are the recovery ID.
\end{definition}

\begin{definition}
    Extra data, $E$, is a tuple containing additional meta data about the
    transaction and the system it is meant to be executed in. 

    \[
        E := (S_v, Tx_v, G, M, N, W, C, L, DR, ER, PA)
    \]

    where each value represents:
    \begin{itemize}
        \item $S_v$: \todo{Not used?}
        \item $Tx_v$: \todo{Not used?}
        \item $G$: \todo{Not used?}
        \item $M$: Contains the Era.
        \item $N$: A compact integer containing the Nonce.
        \item $W$: \todo{Not used?}
        \item $C$: A compact integer containing the transactor pay including tip.
        \item $L$: \todo{Not used?}
        \item $DR$: \todo{Not used?}
        \item $ER$: \todo{Not used?}
        \item $PA$: \todo{Not used?}
    \end{itemize}

\end{definition}

$M_i$ is an indicator for the Runtime to which Polkadot \textit{module}, $m$,
the extrinsic should be forwarded to. The second item, $F_i(m)$, indicates
which \textit{function} (the actual extrinsic) of the specified module should
be executed.
\newline

$M_i$ is a varying data types pointing to every module exposed to the network.

\[
M_i :=
\begin{cases}
0, & \text{System} \\
1, & \text{Utility} \\
... & \\
7, & \text{Balances} \\
... &
\end{cases}
\]

The $F_i(m)$ indicator varies for each module, since every module has different
functions. As an example, the \verb|Balances| module offers the following
functions:

\[
F(Balances)_i :=
\begin{cases}
0, & \text{transfer} \\
1, & \text{set\_balance} \\
2 & \text{force\_transfer} \\
3 & \text{transfer\_keep\_alive} \\
\end{cases}
\]

As an example, the \verb|transfer| function takes two parameters, 
