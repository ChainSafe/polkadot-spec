\documentclass{article}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,amssymb,calc,ifthen,alltt,capt-of}
\geometry{letterpaper, paperheight= auto, paperwidth= auto}

%%%%%%%%%% Start TeXmacs macros
\newcommand{\assign}{:=}
\newcommand{\cdummy}{\cdot}
\newcommand{\nin}{\not\in}
\newcommand{\nobracket}{}
\newcommand{\nosymbol}{}
\newcommand{\tmcodeinline}[2][]{{\ttfamily{#2}}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmname}[1]{\textsc{#1}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmrsub}[1]{\ensuremath{_{\textrm{#1}}}}
\newcommand{\tmsamp}[1]{\textsf{#1}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmtextbf}[1]{{\bfseries{#1}}}
\newcommand{\tmtextit}[1]{{\itshape{#1}}}
\newcommand{\tmtextsc}[1]{{\scshape{#1}}}
\newcommand{\tmtextsf}[1]{{\sffamily{#1}}}
\newcommand{\tmtexttt}[1]{{\ttfamily{#1}}}
\newcommand{\tmverbatim}[1]{{\ttfamily{#1}}}
\newenvironment{itemizedot}{\begin{itemize} \renewcommand{\labelitemi}{$\bullet$}\renewcommand{\labelitemii}{$\bullet$}\renewcommand{\labelitemiii}{$\bullet$}\renewcommand{\labelitemiv}{$\bullet$}}{\end{itemize}}
\newenvironment{itemizeminus}{\begin{itemize} \renewcommand{\labelitemi}{$-$}\renewcommand{\labelitemii}{$-$}\renewcommand{\labelitemiii}{$-$}\renewcommand{\labelitemiv}{$-$}}{\end{itemize}}
\newenvironment{tmcode}[1][]{\begin{alltt} }{\end{alltt}}
\newcounter{tmcounter}
\newcommand{\custombinding}[1]{%
  \setcounter{tmcounter}{#1}%
  \addtocounter{tmcounter}{-1}%
  \refstepcounter{tmcounter}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newcommand{\tmfloatcontents}{}
\newlength{\tmfloatwidth}
\newcommand{\tmfloat}[5]{
  \renewcommand{\tmfloatcontents}{#4}
  \setlength{\tmfloatwidth}{\widthof{\tmfloatcontents}+1in}
  \ifthenelse{\equal{#2}{small}}
    {\setlength{\tmfloatwidth}{0.45\linewidth}}
    {\setlength{\tmfloatwidth}{\linewidth}}
  \begin{minipage}[#1]{\tmfloatwidth}
    \begin{center}
      \tmfloatcontents
      \captionof{#3}{#5}
    \end{center}
  \end{minipage}}
%%%%%%%%%% End TeXmacs macros

\providecommand{\cdummy}{{\cdot}}
\providecommand{\nobracket}{}
\providecommand{\nosymbol}{}
\providecommand{\tmem}[1]{\tmtextit{#1}}
\providecommand{\tmname}[1]{\tmtextsc{#1}}
\providecommand{\tmop}[1]{\ensuremath{\mathrm{#1}}}
\providecommand{\tmrsub}[1]{\tmrsub{\ensuremath{\mathrm{#1}}}}
\providecommand{\tmsamp}[1]{\tmtextsf{#1}}
\providecommand{\tmstrong}[1]{\tmtextbf{#1}}
\providecommand{\tmtextbf}[1]{\tmtextbf{#1}}
\providecommand{\tmtextit}[1]{\tmtextit{#1}}
\providecommand{\tmverbatim}[1]{\tmtexttt{#1}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newcommand{\figuretext}{Snippet}
\newcommand{\figuretext}{Figure}

\begin{document}

\title{
  Polkadot Runtime Environment\\
  {\Large Protocol Specification}
}

\date{May 10, 2019}

\maketitle

\section{Conventions and Definitions}

\begin{definition}
  {\tmstrong{Runtime}} is the state transition function of the decentralized
  ledger protocol.\tmverbatim{}
\end{definition}

\begin{definition}
  \label{def-path-graph}A {\tmstrong{path graph}} or a {\tmstrong{path}} of
  $n$ nodes formally referred to as {\tmstrong{$P_n$}}, is a tree with two
  nodes of vertex degree 1 and the other n-2 nodes of vertex degree 2.
  Therefore, $P_n$ can be represented by sequences of $(v_1, \ldots, v_n)$
  where $e_i = (v_i, v_{i + 1})$ for $1 \leqslant i \leqslant n - 1$ is the
  edge which connect $v_i$ and $v_{i + 1}$.
\end{definition}

\begin{definition}
  \label{defn-radix-tree}{\tmstrong{Radix-r tree}} is a variant of \ a trie in
  which:
  \begin{itemize}
    \item Every node has at most $r$ children where $r = 2^x$ for some $x$;
    
    \item Each node that is the only child of a parent, which does not
    represent a valid key is merged with its parent.
  \end{itemize}
\end{definition}

As a result, in a radix tree, any path whose interior vertices all have only
one child and does not represent a valid key in the data set, is compressed
into a single edge. This improves space efficiency when the key space is
sparse.

\begin{definition}
  By a {\tmstrong{sequences of bytes}} or a {\tmstrong{byte array}}, $b$, of
  length $n$, we refer to
  \[ b \assign (b_0, b_1, ..., b_{n - 1})  \text{such that } 0 \leqslant b_i
     \leqslant 255 \]
  We define $\mathbb{B}_n$ to be the {\tmstrong{set of all byte arrays of
  length $n$}}. Furthermore, we define:
  \[ \mathbb{B} \assign \bigcup^{\infty}_{i = 0} \mathbb{B}_i \]
\end{definition}

\begin{notation}
  We represent the concatenation of byte arrays $a \assign (a_0, \ldots, a_n)$
  and $b \assign (b_0, \ldots, b_m)$ by:
  \[ a || b \assign (a_0, \ldots, a_n, b_0, \ldots, b_m) \]
\end{notation}

\begin{definition}
  \label{defn-bit-rep}For a given byte $b$ the {\tmstrong{bitwise
  representation}} of $b$ is defined as
  \[ b \assign b^7 \ldots b^0 \]
  where
  \[ b = 2^0 b^0 + 2^1 b^1 + \cdots + 2^7 b^7 \]
\end{definition}

\begin{definition}
  \label{defn-little-endian}By \tmverbatim{}the {\tmstrong{little-endian}}
  representation of a non-negative integer, I, represented as
  \[ I = (B_n \ldots B_0)_{256} \]
  in base 256, we refer to a byte array $B = (b_0, b_1, \ldots, b_n)$ such
  that
  \[ b_i \assign B_i \]
  Accordingly, define the function $\tmop{Enc}_{\tmop{LE}}$:
  \[ \begin{array}{llll}
       \tmop{Enc}_{\tmop{LE}} : & \mathbb{Z}^+ & \rightarrow & \mathbb{B}\\
       & (B_n \ldots B_0)_{256} & \mapsto & (B_{0,} B_1, \ldots_{}, B_n)
     \end{array} \]
  
\end{definition}

\begin{definition}
  By {\tmname{{\tmstrong{\tmverbatim{UINT32}}}}} we refer to a non-negative
  integer stored in a byte array of length 4 using little-endian encoding
  format.
\end{definition}

\begin{definition}
  A {\tmstrong{blockchain}} $C$ is a directed path graph. Each node of the
  graph is called {\tmstrong{Block}} and indicated by {\tmstrong{$B$}}. The
  unique sink of $C$ is called {\tmstrong{Genesis Block}}, and the source is
  called the {\tmstrong{Head}} of C. For any vertex $(B_1, B_2)$ where $B_1
  \rightarrow B_2$ we say $B_2$ is the {\tmstrong{parent}} of $B_1$ and we
  indicate it by
  \[ B_2 \assign P (B_1) \]
\end{definition}

\subsection{Block Tree}

In the course of formation of a (distributed) blockchain, it is possible that
the chain forks into multiple subchains in various block positions. We refer
to this structure as a {\tmem{block tree:}}

\begin{definition}
  \label{defn-block-tree}The {\tmstrong{block tree}} of a blockchain, denoted
  by $\tmop{BT}$ is the union of all different versions of the blockchain
  observed by all the nodes in the system such as every such block is a node
  in the graph and $B_1$ is connected to $B_2$ if $B_1$ is a parent of $B_2$.
\end{definition}

Definition \ref{defn-chain-subchain} gives the means to highlight various
branches of the block tree.

\begin{definition}
  \label{defn-chain-subchain}Let $G$ be the root of the block tree and $B$ be
  a node of it. By {\tmname{{\tmstrong{Chain($B$)}},}} we refer to the path
  graph from $G$ to $B$ in $\tmop{BT}$. If $B'$ is another node on
  {\tmname{Chain($B$)}}, then by {\tmname{SubChain($B', B$)}} we refer to the
  subgraph of {\tmname{Chain($B$)}} path graph which contains both $B$ and
  $B'$. {\tmname{Longest-Path($\tmop{BT}$)}} returns a path graph of
  $\tmop{BT}$ which is the longest among all paths in $\tmop{BT}$.
  {\tmname{Deepest-Leaf($\tmop{BT}$)}} returns the head of
  {\tmname{Longest-Path($\tmop{BT}$)}} chain.
\end{definition}

Because every block in the blockchain contains a reference to its parent, it
is easy to see that the block tree is de facto a tree.

A block tree naturally imposes partial order relationships on the blocks as
follows:

\begin{definition}
  We say {\tmstrong{B is descendant of $B'$}}, formally noted as {\tmstrong{$B
  > B'$}} if $B$ is a descendant of $B'$ in the block tree.
\end{definition}

\section{Block Format}

In Polkadot RE, a block is made of two main parts, namely the \tmtextit{block
header} and the \tmtextit{list of extrinsics}. {\tmem{The Extrinsics}}
represent the generalization of the concept of {\tmem{transaction}},
containing any set of data that is external to the system, and which the
underlying chain wishes to validate and keep track of.

\subsection{Block Header}\label{block}

The block header is designed to be minimalistic in order to boost the
efficiency of the light clients. It is defined formally as follows:

\begin{definition}
  \label{def-block-header}The {\tmstrong{header of block B}},
  {\tmstrong{$\tmop{Head} (B)$}} is a 5-tuple containing the following
  elements:
  \begin{itemize}
    \item \tmtextbf{{\tmsamp{parent\_hash:}}} is the 32-byte Blake2s hash of
    the header of the parent of the block indicated henceforth by
    \tmtextbf{$H_p$}.
    
    \item {\tmstrong{{\tmsamp{number:}}}} formally indicated as
    {\tmstrong{$H_i$}} is an integer, which represents the index of the
    current block in the chain. It is equal to the number of the ancestor
    blocks. The genesis block has number 0.
    
    \item {\tmstrong{{\tmsamp{state\_root:}}}} formally indicated as
    {\tmstrong{$H_r$}} is the root of the Merkle trie, whose leaves implement
    the storage for the system.
    
    \item {\tmstrong{{\tmsamp{extrinsics\_root:}}}} is the field which is
    reserved for the runtime to validate the integrity of the extrinsics
    composing the block body. For example, it can hold the root hash of the
    Merkle trie which stores an ordered list of the extrinsics being validated
    in this block. The {\tmsamp{extrinsics\_root}} is set by the runtime and
    its value is opaque to Polkadot RE. This element is formally referred to
    as {\tmstrong{$H_e$}}.
    
    \item {\tmstrong{{\tmsamp{digest:}}}} this field is used to store any
    chain-specific auxiliary data, which could help the light clients interact
    with the block without the need of accessing the full storage. Polkadot RE
    does not impose any limitation or specification for this field.
    Essentially, it can be a byte array of any length. This field is indicated
    as {\tmstrong{$H_d$}}
  \end{itemize}
\end{definition}

\begin{definition}
  \label{def-block-header-hash}The {\tmstrong{Block Header Hash of Block
  $B$}}, {\tmstrong{$H_h (b)$}}, is the hash of the header of block $B$
  encoded by simple codec:
  \[ H_b (b) \assign \tmop{Blake} 2 s (\tmop{Enc}_{\tmop{SC}} (\tmop{Head}
     (B))) \]
\end{definition}

\subsection{Justified Block Header}

The Justified Block Header is provided by the consensus engine and presented
to the Polkadot RE, for the block to be appended to the blockchain. It
contains the following parts:
\begin{itemize}
  \item {\tmstrong{{\tmsamp{{\tmstrong{block\_header}}}}}} the complete block
  header as defined in Section \ref{block} and denoted by $\tmop{Head} (B)$.
  
  \item {\tmstrong{{\tmsamp{justification}}}}: as defined by the consensus
  specification indicated by $\tmop{Just} (B)$ {\todo{link this to its
  definition from consensus}}.
  
  \item {\tmstrong{{\tmsamp{authority Ids}}}}: This is the list of the Ids of
  authorities, which have voted for the block to be stored and is formally
  referred to as $A (B)$. An authority Id is 32bit.
\end{itemize}

\subsection{Processing Extrinsics}

The block body consists of a set of extrinsics. Nonetheless, Polkadot RE does
not specify or limit the internals of each extrinsics. From Polkadot RE point
of view, each extrinsics is a SCALE encoded in byte arrays (see Definition
\ref{def-scale-byte-array}).

The extrinsics are submitted to the node through the {\tmem{transactions}}
network message specified in Section \ref{sect-message-transactions}. Upon
receiving a transactions message, Polkadot RE separates the submitted
transactions message into individual extrinsics and runs Algorithm
\ref{algo-validate-transactions} to validate them and store them to include
them into future blocks.

\custombinding{1}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  1. }
  \label{algo-validate-transactions}{\tmname{Validate-Extrinsics-and-Store}}($L$:
  list of extrinsics)\\
  \hline
\end{tabular}

{\algorithmic{{\state{{\FORIN{$E$}{$L$}}}}

{\state{$B_d \leftarrow${\tmname{Deepest-Leaf($\tmop{BT}$)}}}}

{\state{$N \leftarrow H_n (B_d)$}}

{\state{$R \leftarrow${\tmname{Call-Runtime-Entry}}$\left(
\text{\tmverbatim{TaggedTransactionQueue\_validate\_transaction}}, N, E
\right)$}}

{\state{{\IF{$R$ indicates $E$ is $\tmop{Valid}$}}}}

{\state{{\tmname{Add-To-Extrinsic-Queue($E, R$)}}}}}}

\hrulefill{\medskip}

\subsection{Extrinsic Queue}

{\todo{To be specced}}

\subsection{Block Format}

\section{Interactions with the Runtime}\label{sect-entries-into-runtime}

Runtime is the code implementing the logic of the chain. This code is
decoupled from the Polkadot RE to make the Runtime easily upgradable without
the need to upgrade the Polkadot RE itself. In this section, we describe the
details upon which the Polkadot RE is interacting with the Runtime.

\subsection{Loading the Runtime code \ \ }

Polkadot RE expects to receive the code for the runtime of the chain as a
compiled WebAssembly (Wasm) Blob. The current runtime is stored in the state
database under the key represented as a byte array:
\[ b \assign \text{3A,63,6F,64,65} \]
which is the byte array of ASCII representation of string ``:code'' (see
Section \ref{sect-predef-storage-keys}). For any call to the runtime, Polkadot
RE makes sure that it has the most updated Runtime as calls to runtime have
potentially the ability to change the runtime code.

The initial runtime code of the chain is embedded as an extrinsics into the
chain initialization JSON file and is submitted to Polkadot RE (see Section
\ref{sect-genisis-block}).

Subsequent calls to the runtime have the ability to call the storage API (see
Section \ref{sect-runtime-api}) to insert a new Wasm blob into runtime storage
slot to upgrade the runtime.

\subsection{Code Executor}

Polkadot RE provides a Wasm Virtual Machine (VM) to run the Runtime. The Wasm
VM exposes the Polkadot RE API to the Runtime, which, on its turn, executes a
call to the Runtime entries stored in the Wasm module. This part of the
Runtime environment is referred to as the {\tmem{{\tmstrong{Executor}}.}}

Definition \ref{nota-call-into-runtime} introduces the notation for calling
the runtime entry which is used whenever an algorithm of Polkadot RE needs to
access the runtime.

\begin{notation}
  \label{nota-call-into-runtime} By
  \[ \text{{\tmname{Call-Runtime-Entry}}} \left(
     \text{\tmverbatim{Runtime-Entry}}, A_1, A_2, \ldots, A_n \right) \]
  we refer to the task using the execuping me cherie when the edits are
  readytor to invoke the \tmverbatim{Runtime-Entry} while passing an $A_1,
  \ldots, A_n$ argument to it and using the encoding described in Section
  \ref{sect-send-args-to-runtime}.
\end{notation}

In this section, we specify the general setup for an Executor call into the
Runtime. In Section \ref{sect-runtime-entries} we specify the parameters and
the return values of each Runtime entry separately.

\subsubsection{Access to Runtime API}

When Polkadot RE calls a Runtime entry it should make sure Runtime has access
to the all Polkadot Runtime API functions described in Appendix
\ref{sect-runtime-api}. This can be done for example by loading another Wasm
module alongside the runtime which imports these functions from Polkadot RE as
host functions.

\subsubsection{Sending Arguments to Runtime }\label{sect-send-args-to-runtime}

In general, all data exchanged between Polkadot RE and the Runtime is encoded
using SCALE codec described in Section \ref{sect-scale-codec}. As a Wasm
function, all runtime entries have the following identical signatures:

\

\tmcodeinline[cpp]{\tmverbatim{}(func \$runtime\_entry (param \$data i32)
(param \$len i32) (result i64))}

\

In each invocation of a Runtime entry, the arguments which are supposed to be
sent to the entry, need to be encoded using SCALE codec into a byte array $B$
using the procedure defined in Definition \ref{defn-scale-tuple}.

The Executor then needs to retrieve the Wam memory buffer of the Runtime Wasm
module and extend it to fit the size of the byte array. Afterwards, it needs
to copy the byte array $B$ value in the correct offset of the extended buffer.
Finally, when the Wasm method \tmverbatim{runtime\_entry}, corresponding to
the entry is invoked, two UINT32 integers are sent to the method as arguments.
The first argument \tmverbatim{data} is set to the offset where the byte array
$B$ is stored in the Wasm the extended shared memory buffer. The second
argument \tmverbatim{len} sets the length of the data stored in $B$., and the
second one is the size of $B$.

\subsubsection{The Return Value from a Runtime Entry}

The value which is returned from the invocation is an \tmverbatim{i64}
integer, representing two consecutive \tmverbatim{i32} integers in which the
least significant one indicates the pointer to the offset of the result
returned by the entry encoded in SCALE codec in the memory buffer. The most
significant one provides the size of the blob.

In the case that the runtime entry is returning a boolean value, then the
SCALEd value returns in the least significant byte and all other bytes are set
to zero.

\subsection{Entries into Runtime}\label{sect-runtime-entries}

Polkadot RE assumes that at least the following functions are implemented in
the Runtime Wasm blob and has been exported as shown in Snippet
\ref{snippet-runtime-enteries}:

\tmfloat{h}{small}{figure}{\begin{tmcode}[cpp]
  (export "Core_version" (func $Core_version))
  (export "Core_authorities" (func $Core_authorities))
  (export "Core_execute_block" (func $Core_execute_block))
  (export "Core_initialise_block" (func $Core_initialise_block))
  (export "Metadata_metadata" (func $Metadata_metadata))
  (export "BlockBuilder_apply_extrinsic" (func $BlockBuilder_apply_extrinsic))
  (export "BlockBuilder_finalise_block" (func $BlockBuilder_finalise_block))
  (export "BlockBuilder_inherent_extrinsics" 
          (func $BlockBuilder_inherent_extrinsics))
  (export "BlockBuilder_check_inherents" (func $BlockBuilder_check_inherents))
  (export "BlockBuilder_random_seed" (func $BlockBuilder_random_seed))
  (export "TaggedTransactionQueue_validate_transaction" 
          (func $TaggedTransactionQueue_validate_transaction))
  (export "OffchainWorkerApi_offchain_worker" 
          (func $OffchainWorkerApi_offchain_worker))
  (export "ParachainHost_duty_roster" (func $ParachainHost_duty_roster))
  (export "ParachainHost_active_parachains" 
          (func $ParachainHost_active_parachains))
  (export "ParachainHost_parachain_head" (func $ParachainHost_parachain_head))
  (export "ParachainHost_parachain_code" (func $ParachainHost_parachain_code))
  (export "GrandpaApi_grandpa_pending_change" 
          (func $GrandpaApi_grandpa_pending_change))
  (export "GrandpaApi_grandpa_forced_change" 
          (func $GrandpaApi_grandpa_forced_change))
  (export "GrandpaApi_grandpa_authorities" 
          (func $GrandpaApi_grandpa_authorities))
  (export "ParachainHost_validators" (func $Core_authorities))
 
  (export "BabeApi_slot_winning_threshold" 
          (func $BabeApi_slot_winning_threshold))
\end{tmcode}}{\label{snippet-runtime-enteries}Snippet to export entries into
tho Wasm runtime module}

The following sections describe the standard based on which Polkadot RE
communicates with each runtime entry.

\subsubsection{\tmverbatim{Core\_version}}

This entry receives no argument; it returns the version data encoded in ABI
format described in Section \ref{sect-abi-encoding} containing the following
data:

\

\begin{center}
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    \hline
    Name & Type & Description\\
    \hline
    \tmverbatim{spec\_name} & String & runtime identifier\\
    \tmverbatim{impl\_name} & String & the name of the implementation (e.g.
    C++)\\
    \tmverbatim{authoring\_version} & UINT32 & the version of the authorship
    interface\\
    \tmverbatim{spec\_version} & UINT32 & the version of the runtime
    specification\\
    \tmverbatim{impl\_version} & UINT32 & the version of the runtime
    implementation\\
    \tmverbatim{apis} & ApisVec & List of supported AP\\
    \hline
  \end{tabular}}{Detail of the version data type returns from runtime
  \tmverbatim{version} function}
\end{center}

\subsubsection{\tmverbatim{Core\_authorities}}\label{sect-runtime-api-auth}

This entry is to report the set of authorities at a given block. It receives
\tmverbatim{block\_id} as an argument; it returns an array of
\tmverbatim{authority\_id}'s.

\subsubsection{\tmverbatim{Core\_execute\_block}}

This entry is responsible for executing all extrinsics in the block and
reporting back the changes into the state storage. It receives the block
header and the block body as its arguments, and it returns a triplet:

\begin{center}
  \
  
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    \hline
    Name & Type & Description\\
    \hline
    \tmverbatim{results} & Boolean & Indicating if the execution was su\\
    \tmverbatim{storage\_changes} & {\todo{???}} & Contains all changes to the
    state storage\\
    \tmverbatim{change\_updat} & {\todo{???}} & \\
    \hline
  \end{tabular}}{Detail of the data execute\_block returns after execution}
\end{center}

\subsubsection{\tmverbatim{Core\_initialise\_block}}

\subsubsection{\tmverbatim{TaggedTransactionQueue\_validate\_transaction}}\label{sect-validate-transaction}

{\todo{Explain function}}

\section{Network Interactions}

\subsection{Extrinsics Submission}

Extrinsic submission is made by sending a {\tmem{Transactions}} network
message. The structure of this message is specified in Section
\ref{sect-message-transactions}.

Upon receiving an Transactions message, Polkadot RE decodes the transaction
and calls \tmverbatim{validate\_trasaction} runtime function defined in
Section \ref{sect-validate-transaction}, to check the validity of the
extrinsic. If \tmverbatim{validate\_transaction} considers the submitted
extrinsics as a valid one, Polkadot RE makes the extrinsics available for the
consensus engine for inclusion in future blocks.

\subsection{Network Messages}

This section specifies various types of messages which Polkadot RE receives
from the network. Furthermore, it also explains the appropriate responses to
those messages.

\subsection{General structure of network messages}

\begin{definition}
  A {\tmstrong{network message}} is a byte array, {\tmstrong{$M$}} of length
  $\| M \|$ such that:
  
  
  \[ \begin{array}{cc}
       M_1 & \tmop{Message} \tmop{Type} \tmop{Indicator}\\
       M_2 \ldots M_{\| M \|} & \tmop{Enc}_{\tmop{SC}} (\tmop{MessageBody})
     \end{array} \]
  
\end{definition}

The body of each message consists of different components based on its type.
The different possible message types are listed below in Table
\ref{tabl-message-types}. We describe the sub-components of each message type
individually in Section \ref{sect-message-detail}.

\begin{table}[h]
  \begin{tabular}{|c|c|c|}
    \hline
    $M_1$ & Message Type & Description\\
    \hline
    0 & Status & \\
    1 & Block Request & \\
    2 & Block Response & \\
    3 & Block Announce & \\
    4 & Transactions & \\
    5 & Consensus & \\
    6 & Remote Call Request & \\
    7 & Remote Call Response & \\
    8 & Remote Read Request & \\
    9 & Remote Read Response & \\
    10 & Remote Header Request & \\
    11 & Remote Header Response & \\
    12 & Remote Changes Request & \\
    13 & Remote Changes Response & \\
    255 & Chain Specific & \\
    \hline
  \end{tabular}
  \caption{\label{tabl-message-types}List of possible network message types}
\end{table}

\subsection{Detailed Message Structure}\label{sect-message-detail}

This section disucsses the detailed structure of each network message.

\subsubsection{Transactions}\label{sect-message-transactions}

\ \ \ The transactions Message is represented by $M_T$ and is defined as
follows:
\[ M_T \assign \tmop{Enc}_{\tmop{SC}} (C_1, \ldots, C_n) \]
in which:
\[ C_i \assign \tmop{Enc}_{\tmop{SC}} (E_i) \]
Where each $E_i$ is a byte array and represents a sepearate extrinsic.
Polkadot RE is indifferent about the content of an extrinsic and treats is as
a blob of data.

\subsection{Block Submission and Validation}

Block validation is the process, by which the client asserts that a block is
fit to be added to the blockchain. This means that the block is consistent
with the world state and transitions from the state of the system to a new
valid state.

Blocks can be handed to the Polkadot RE both from the network stack and from
the consensus engine.

Both the Runtime and the Polkadot RE need to work together to assure block
validity. This can be accomplished by Polkadot RE invoking
\tmverbatim{execute\_block} entry into the runtime as a part of the validation
process.

Polkadot RE implements the following procedure to assure the validity of the
block:

\custombinding{2}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  2. } {\tmname{Import-and-Validate-Block($B, \tmop{Just}
  (B)$)}}\\
  \hline
\end{tabular}

{\algorithmic{{\state{{\tmname{Verify-Block-Justification}}$(B, \tmop{Just}
(B))$}}

{\state{{\IF{$B$ {\tmstrong{is}} Finalized {\tmstrong{and}} $P (B)$
{\tmstrong{is not}} Finalized}}}}

{\state{{\tmname{Mark-as-Final}}$(P (B))${\END}}}

{\state{Verify $H_{p (B)} \in \tmop{Blockchain}$}}

{\state{State-Changes = Runtime{\tmname{$(B)$}}}}

{\state{{\tmname{Update-World-State}}(State-Changes)}}}}

\hrulefill{\medskip}

For the definition of the finality and the finalized block see Section
\ref{sect-finality}.

\section{State Storage and the Storage Trie}

For storing the state of the system, Polkadot RE implements a hash table
storage where the keys are used to access each data entry. There is no
assumption either on the size of the key nor on the size of the data stored
under them, besides the fact that they are byte arrays with specific upper
limits on their length. The limit is imposed by the encoding algorithms to
store the key and the value in the storage trie.

\subsection{Accessing The System Storage }

Polkadot RE implements various functions to facilitate access to the system
storage for the runtime. Section \ref{sect-runtime-api} lists all of those
functions. Here we formalize the access to the storage when it is being
directly accessed by Polkadot RE (in contrast to Polkadot runtime).

\begin{definition}
  \label{defn-stored-value}The {\tmstrong{StoredValue}} function retrieves the
  value stored under a specific key in the state storage and is formally
  defined as :
  \[ \begin{array}{cc}
       \tmop{StoredValue} : & \mathcal{K} \rightarrow \mathcal{V}\\
       & k \mapsto \left\{ \begin{array}{cc}
         v & \text{if (k,v) exists in state storage}\\
         \phi & \tmop{otherwise}
       \end{array} \right.
     \end{array} \]
  where $\mathcal{K} \subset \mathbb{B}$ and $\mathcal{V} \subset \mathbb{B}$
  are respectively the set of all keys and values stored in the state storage.
  
  \ 
\end{definition}

\subsection{The General Tree Structure}

In order to ensure the integrity of the state of the system, the stored data
needs to be re-arranged and hashed in a {\tmem{modified Merkle Patricia
Tree}}, which hereafter we refer to as the {\tmem{{\tmstrong{Trie}}}}. This
rearrangment is necessary to be able to compute the Merkle hash of the whole
or part of the state storage, consistently and efficiently at any given time.

The Trie is used to compute the {\tmem{state root}}, $H_r$, (see Definition
\ref{def-block-header}), whose purpose is to authenticate the validity of the
state database. Thus, Polkadot RE follows a rigorous encoding algorithm to
compute the values stored in the trie nodes to ensure that the computed Merkle
hash, $H_r$, matches across the Polkadot RE implementations.

The Trie is a {\tmem{radix-16}} tree as defined in Definition
\ref{defn-radix-tree}. Each key value identifies a unique node in the tree.
However, a node in a tree might or might not be associated with a key in the
storage.

When traversing the Trie to a specific node, its key can be reconstructed by
concatenating the subsequences of the key which are stored either explicitly
in the nodes on the path or implicitly in their position as a child of their
parent.

To identify the node corresponding to a key value, $k$, first we need to
encode $k$ in a consistent with the Trie structure way. Because each node in
the trie has at most 16 children, we represent the key as a sequence of 4-bit
nibbles:

\begin{definition}
  For the purpose of labeling the branches of the Trie, the key $k$ is encoded
  to $k_{\tmop{enc}}$ using KeyEncode functions:
  \begin{equation}
    k_{\tmop{enc}} \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
    \assign \tmop{KeyEncode} (k) \label{key-encode-in-trie}
  \end{equation}
  such that:
  \[ \tmop{KeyEncode} (k) : \left\{ \begin{array}{lll}
       \mathbb{B}^{\nosymbol} & \rightarrow & \tmop{Nibbles}^4\\
       k \assign (b_1, \ldots, b_n) \assign & \mapsto & (b^1_1, b^2_1, b_2^1,
       b^2_2, \ldots, b^1_n, b^2_n)\\
       &  & \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
     \end{array} \right. \]
  where $\tmop{Nibble}^4$ is the set of all nibbles of 4-bit arrays and
  $b^1_i$ and $b^2_i$ are 4-bit nibbles, which are the big endian
  representations of $b_i$:
  \[ (b^1_i, b^2_i) \assign (b_i / 16, b_i \tmop{mod} 16) \]
  , where mod is the remainder and / is the integer division operators.
\end{definition}

By looking at $k_{\tmop{enc}}$ as a sequence of nibbles, one can walk the
radix tree to reach the node identifying the storage value of $k$.

\subsection{The Trie structure}

In this subsection, we specify the structure of the nodes in the Trie as well
as the Trie structure:

\begin{notation}
  We refer to the {\tmstrong{set of the nodes of Polkadot state trie}} by
  $\mathcal{N}.$ By $N \in \mathcal{N}$ to refer to an individual node in the
  trie.
\end{notation}

\begin{definition}
  \label{defn-nodetype}The State Trie is a radix-16 tree. Each Node in the
  Trie is identified with a unique key $k_N$ such that:
  \begin{itemizeminus}
    \item $k_N$ is the shared prefix of the key of all the descendants of $N$
    in the Trie.
  \end{itemizeminus}
  and, at least one of the following statements holds:
  \begin{itemizeminus}
    \item $(k_N, v)$ corresponds to an existing entry in the State Storage.
    
    \item N has more than one child.
  \end{itemizeminus}
  Conversely, if $(k, v)$ is an entry in the State Trie then there is a node
  $N \in \mathcal{N}$ such that $k_N$=k.
\end{definition}

\begin{notation}
  A {\tmstrong{branch}} node is a node which has one child or more. A branch
  node can have at most 16 children. A {\tmstrong{leaf}} node is a childless
  node. Accordingly:
  \[ \begin{array}{c}
       \mathcal{N}_b \assign \left\{ N \in \mathcal{N}|N \text{is a branch
       node} \right\}\\
       \mathcal{N}_l \assign \left\{ N \in \mathcal{N}|N \text{is a leaf node}
       \right\}
     \end{array} \]
\end{notation}

For each Node, part of $k_N$ is built while the trie is traversed from root to
$N$ part of $k_N$ is stored in $N$ as formalized in Definition
\ref{defn-node-key}.

\begin{definition}
  \label{defn-node-key}For any $N \in \mathcal{N}$, its key $k_N$ is divided
  into an {\tmstrong{aggregated prefix key}},
  {\tmstrong{$\tmop{pk}_N^{\tmop{Agr}}$}}, aggregated by Algorithm
  \ref{algo-aggregate-key} and a {\tmstrong{partial key}},
  {\tmstrong{$\tmop{pk}_N$}} of length $0 \leqslant l_{\tmop{pk}_N} \leqslant
  65535$ such that:
  \[ \tmop{pk}_N \assign (k_{\tmop{enc}_i}, \ldots, k_{\tmop{enc}_{i +
     l_{\tmop{pk}_N}}}) \]
  where $\tmop{pk}_N$ is a suffix subsequence of $k_N$; and we have:
  \[ \tmop{KeyEncode} (k_N) = \tmop{pk}_N^{\tmop{Agr}} | \tmop{pk}_N =
     (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{i - 1}}, k_{\tmop{enc}_i},
     k_{\tmop{enc}_{i + l_{\tmop{pk}_N}}}) \]
\end{definition}

Part of $\tmop{pk}_N^{\tmop{Agr}}$ is explicitly stored in $N$'s ancestors.
Additionally, for each ancestor, a single nibble is implicitly derived while
traversing from the ancestor to its child included in the traversal path using
the $\tmop{Index}_N$ function defined in Definition \ref{defn-index-function}.

\begin{definition}
  \label{defn-index-function}For $N \in \mathcal{N}_b$ and $N_c$ child of N,
  we define {\tmstrong{$\tmop{Index}_N$}} function as:
  \[ \begin{array}{cc}
       \tmop{Index}_N : & \left\{ N_c \in \mathcal{N}|N_c  \text{is a child of
       N} \right\} \rightarrow \tmop{Nibbles}^4_1\\
       & N_c \mapsto i_{}
     \end{array} \]
  such that
  \[ k_{N_c} = k_N | | i | | \tmop{pk}_{N_c} \]
\end{definition}

Assuming that $P_N$ is the path (see Definition \ref{def-path-graph}) from the
Trie root to node $N$, Algorithm \ref{algo-aggregate-key} rigorously
demonstrates how to build $\tmop{pk}^{\tmop{Agr}}_N$ while traversing $P_N$.

\custombinding{3}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  3. }
  \label{algo-aggregate-key}{\tmname{Aggregate-Key}}$(P_N : = (\tmop{TrieRoot}
  = N_1, \ldots, N_j = N))$\\
  \hline
\end{tabular}

{\algorithmic{{\state{$\tmop{pk}^{\tmop{Agr}}_N \leftarrow \phi$}}

{\state{$i \leftarrow 1$}}

{\state{{\WHILE{$(N_i \neq N)$}}}}

{\state{$\tmop{pk}^{\tmop{Agr}}_N \leftarrow \tmop{pk}^{\tmop{Agr}}_N | |
\tmop{pk}_N $}}

{\state{$\tmop{pk}^{\tmop{Agr}}_N \leftarrow \tmop{pk}^{\tmop{Agr}}_N | |
\tmop{Index}_{N_i} (N_{i + 1})${\END}}}

{\state{{\RETURN{$\tmop{pk}^{\tmop{Agr}}_N$}}}}}}

\hrulefill{\medskip}

\begin{definition}
  \label{defn-node-value}A node $N \in \mathcal{N}$ stores the {\tmstrong{node
  value}}, {\tmstrong{$v_N$}}, which consists of the following concatenated
  data:
  \[ \begin{array}{|l|l|l|}
       \hline
       \tmop{Node} \tmop{Header} & \tmop{Partial} \tmop{key} & \tmop{Node}
       \tmop{Subvalue}\\
       \hline
     \end{array} \]
  Formally noted as:
  \[ v_N \assign \tmop{Head}_N | | \tmop{Enc}_{\tmop{HE}} (\tmop{pk}_N) | |
     \tmop{sv}_N \]
  where $\tmop{Head}_N$, $\tmop{pk}_N$, $\tmop{Enc}_{\tmop{nibbles}}$ and
  $\tmop{sv}_N$ are defined in Definitions \ref{defn-node-header},
  \ref{defn-node-key}, \ref{defn-hex-encoding} and \ref{defn-node-subvalue},
  respectively.
\end{definition}

\begin{definition}
  \label{defn-node-header}The {\tmstrong{node header}} of node $N$,
  $\tmop{Head}_N$, consists of $l \geqslant 1$ bytes
  
  
  \[ \begin{array}{ll}
       \hline
       \tmop{Node} \tmop{Type} & \tmop{pk} \tmop{length}\\
       \hline
       \tmop{Head}_{N, 1}^{6 - 7}_{} & \tmop{Head}_{N, 1}^{0 - 5}_{}
     \end{array}  \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{length} \tmop{extra} \tmop{byte} 1\\
       \hline
       \tmop{Head}_{N, 2}\\
       \hline
     \end{array}  \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{key} \tmop{length} \tmop{extra} \tmop{byte} 2\\
       \hline
       \ldots .\\
       \hline
     \end{array} \ldots \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{length} \tmop{extra} \tmop{byte} l\\
       \hline
       \tmop{Head}_{N, l + 1}^{}_{}\\
       \hline
     \end{array} \]
  
  
  In which $\tmop{Head}_{N, 1}^{6 - 7}_{}$, the two most significant bits of
  the first byte of $\tmop{Head}_N$ are determined as follows:
  \[ \tmop{Head}_{N, 1}^{6 - 7}_{} \assign \left\{ \begin{array}{ll}
       00 & \tmop{Special} \tmop{case}\\
       01 & \tmop{Leaf} \tmop{Node}\\
       10 & \tmop{Branch} \tmop{Node} \tmop{with} k_N \nin \mathcal{K}\\
       11 & \tmop{Branch} \tmop{Node} \tmop{with} k_N \in \mathcal{K}
     \end{array} \right. \]
  where $\mathcal{K}$ is defined in Definition \ref{defn-stored-value}.
  
  $\tmop{Head}_{N, 1}^{0 - 5}_{}$, the 6 least significant bits of the first
  byte of $\tmop{Head}_N$ are defined to be:
  \[ \tmop{Head}_{N, 1}^{0 - 5}_{} \assign \left\{ \begin{array}{ll}
       \| \tmop{pk}_N \|_{\tmop{nib}} & \| \tmop{pk}_N \|_{\tmop{nib}} < 63\\
       63 & \| \tmop{pk}_N \|_{\tmop{nib}} \geqslant 63
     \end{array} \right. \]
  In which {\tmstrong{$\| \tmop{pk}_N \|_{\tmop{nib}}$}} is the length of
  $\tmop{pk}_N $ in number nibbles. $\tmop{Head}_{N, 2}, \ldots,
  \tmop{Head}_{N, l}$ bytes are determined by Algorithm \ref{algo-pk-length}.
\end{definition}

\custombinding{4}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  4. }
  \label{algo-pk-length}{\tmname{Partial-Key-Length-Encoding$(\tmop{Head}_{N,
  1}^{6 - 7}_{}, \tmop{pk}_N)$}}\\
  \hline
\end{tabular}

{\algorithmic{{\state{{\IF{$\| \tmop{pk}_N \|_{\tmop{nib}} \geqslant
2^{16}$}}}}

{\state{{\RETURN{Error{\END}}}}}

{\state{$\tmop{Head}_{N, 1} \leftarrow 64 \times \tmop{Head}_{N, 1}^{6 -
7}_{}$}}

{\state{{\IF{$\| \tmop{pk}_N \|_{\tmop{nib}} < 63$}}}}

{\state{$\tmop{Head}_{N, 1} \leftarrow \tmop{Head}_{N, 1} + \| \tmop{pk}_N
\|_{\tmop{nib}}$}}

{\state{{\RETURN{$\tmop{Head}_N \END$}}}}

{\state{$\tmop{Head}_{N, 1} \leftarrow \tmop{Head}_{N, 1} + 63$}}

{\state{$l \leftarrow \| \tmop{pk}_N \|_{\tmop{nib}} - 62$}}

{\state{$i \leftarrow 2$}}

{\state{{\WHILE{$(l > 255)$}}}}

{\state{$\tmop{Head}_{N, i} \leftarrow 255$}}

{\state{$l \leftarrow l - 255$}}

{\state{$i \leftarrow i + 1 \END$}}

{\state{$\tmop{Head}_{N, i} \leftarrow l - 1$}}

{\state{{\RETURN{$\tmop{Head}_N$}}}}}}

\hrulefill{\medskip}

\subsection{The Merkle proof}\label{sect-merkl-proof}

To prove the consistency of the state storage across the network and its
modifications both efficiently and effectively, the Trie implements a Merkle
tree structure. The hash value corresponding to each node needs to be computed
rigorously to make the inter-implementation data integrity possible.

The Merkle value of each node should depend on the Merkle value of all its
children as well as on its corresponding data in the state storage. This
recursive dependancy is encompassed into the subvalue part of the node value
which recursively depends on the Merkle value of its children.

We use the auxilary function introduced in Definition
\ref{defn-children-bitmap} to encode and decode information stored in a branch
node.

\begin{definition}
  \label{defn-children-bitmap}Suppose $N_b, N_c \in \mathcal{N}$ and $N_c$ is
  a child of $N_b$. We define where bit $b_i : = 1$ if $N$ has a child with
  partial key $i$, therefore we define {\tmstrong{ChildrenBitmap}} functions
  as follows:
  \[ \begin{array}{cc}
       \tmop{ChildrenBitmap} : & \mathcal{N}_b \rightarrow \mathbb{B}_2\\
       & N \mapsto (b_{15}, \ldots, b_8, b_7, \ldots b_0)_2
     \end{array} \]
  where
  \[ b_i \assign \left\{ \begin{array}{cc}
       1 & \exists N_c \in \mathcal{N}: k_{N_c} = k_{N_b} | | i | |
       \tmop{pk}_{N_c}\\
       0 & \text{otherwise}
     \end{array} \right. \]
\end{definition}

\begin{definition}
  \label{defn-node-subvalue}For a given node $N$, the {\tmstrong{subvalue}} of
  $N$, formally referred to as $\tmop{sv}_N$, is determined as follows: in a
  case which:
  \begin{itemize}
    \[ \begin{array}{l}
         \tmop{sv}_N \assign\\
         \left\{ \begin{array}{cc}
           \tmop{Enc}_{\tmop{SC}} (\tmop{StoredValue} (k_N)) & \text{N is a
           leaf node}\\
           \nobracket \tmop{ChildrenBitmap} (N)\|H (N_{C_1}) \ldots H
           (N_{C_n}) | | \tmop{Enc}_{\tmop{SC}} (\tmop{StoredValue} (k_N))  &
           \text{N is a branch node}
         \end{array} \right.
       \end{array} \]
  \end{itemize}
\end{definition}

Where $N_{C_1} \ldots N_{C_n}$ with $n \leqslant 16$ are the children nodes of
the branch node $N$ and Enc\tmrsub{SC}, $\tmop{StoredValue}$, $H$, and
$\tmop{ChildrenBitmap} (N)$ are defined in Definitions \ref{def-scale-codec},
\ref{defn-stored-value}, \ref{defn-merkle-value} and
\ref{defn-children-bitmap} respectively.

\

The Trie deviates from a traditional Merkle tree where node value, $v_N$ (see
Definition \ref{defn-node-value}) is presented instead of its hash if it
occupies less space than its hash.

\begin{definition}
  \label{defn-merkle-value}For a given node $N$, the {\tmstrong{Merkle value}}
  of $N$, denoted by $H (N)$ is defined as follows:
  \[ \begin{array}{lll}
       & H : \mathbb{B} \rightarrow \mathbb{B}_{32} & \\
       & H (N) : \left\{ \begin{array}{lll}
         v_N | | 0_{B_{32 - \| v_N \|}} & \|v_N \|< 32 & \\
         \tmop{Blake} 2 s (v_N) & \|v_N \| \geqslant 32 & 
       \end{array} \right. & 
     \end{array} \]
  Where $0_{32 - \| v_N \|}$ an all zero byte array of length $32 - | | v_N |
  |$.
\end{definition}

\section{Transactions}

\subsection{Preliminaries}

\begin{definition}
  \label{defn-account-key}{\tmstrong{Account key $(\tmop{sk}^a,
  \tmop{pk}^a)$}} is a pair of Ristretto SR25519 used to sign transactions
  among other accounts and blance-related functions.
\end{definition}

\section{Consensus Engine}

Consensus in Polkadot RE is achieved during the execution of two different
procedures. The first procedure is block production and the second is
finality. Polkadot RE must run these procedures, if and only if it is running
on a validator node.

\subsection{Block Production}

Polkadot RE uses BABE protocol {\cite{w3f_research_group_blind_2019}} for
block production designed based on Ouroboros praos
{\cite{david_ouroboros_2018}}. BABE execution happens in sequential
non-overlapping phases known as an {\tmstrong{{\tmem{epoch}}}}. Each epoch on
its turn is divided into a predefined number of slots. All slots in each epoch
are sequentially indexed starting from 0. At the beginning of each epoch, the
BABE node needs to run Algorithm \ref{algo-block-production-lottery} to find
out in which slots it should produce a block and gossip to the other block
producers. In turn, the block producer node should keep a copy of the block
tree and grow it as it receives valid blocks from other block producers. A
block producer prunes the tree in parallel using Algorithm
\ref{algo-block-tree-prunning}.

\subsubsection{Preliminaries}

\begin{definition}
  A {\tmstrong{block producer}}, noted by $\mathcal{P}_j$, is a node running
  Polkadot RE which is authorized to keep a transaction queue and which gets a
  turn in producing blocks.
\end{definition}

\begin{definition}
  {\tmstrong{Block authring session key pair $(\tmop{sk}^s_j,
  \tmop{pk}^s_j)$}} is an SR25519 key pair which the block producer
  $\mathcal{P}_j$ signs by their account key (see Definition
  \ref{defn-account-key}) and is used to sign the produced block as well as to
  compute its lottery values in Algorithm \ref{algo-block-production-lottery}.
  
\end{definition}

\begin{definition}
  A block production {\tmstrong{epoch}}, formally referred to as $\mathcal{E}$
  is a period with pre-known starting time and fixed length during which the
  set of block producers stays constant. Epochs are indexed sequentially, and
  we refer to the $n^{\tmop{th}}$ epoch since genesis by $\mathcal{E}_n$. Each
  epoch is divided into equal length periods known as block production
  {\tmstrong{slots}}, sequentially indexed in each epoch. Each slot is awarded
  to a subset of block producers during which they are allowed to generate a
  block.
\end{definition}

\begin{notation}
  \label{note-slot}We refer to the number of slots in epoch $\mathcal{E}_n$ by
  $\tmop{sc}_n$. $\tmop{sc}_n$ is set to the result of calling runtime entry \
  \tmverbatim{BabeApi\_slot\_duration} at the ``beginning of each epoch. For a
  given block $B$, we use the notation {\tmstrong{$s_B$}} to refer to the slot
  during which $B$ has been produced. Conversely, for slot $s$,
  $\mathcal{B}_s$ is the set of Blocks generated at slot $s$.
\end{notation}

Definition \ref{defn-epoch-subchain} provides an iterator over the blocks
produced during an specific epoch.

\begin{definition}
  \label{defn-epoch-subchain} By {\tmname{SubChain($\mathcal{E}_n$)}} for
  epoch $\mathcal{E}_n$, we refer to the path graph of $\tmop{BT}$ which
  contains all the blocks generated during the slots of epoch $\mathcal{E}_n$.
  When there is more than one block generated at a slot, we choose the one
  which is also on {\tmname{Longest-Branch($\tmop{BT}$)}}.
\end{definition}

\subsubsection{Block Production Lottery}

\begin{definition}
  {\tmstrong{Winning threshold}} denoted by {\tmstrong{$\tau$}} is the
  threshold which is used alongside with the result of Algorirthm
  \ref{algo-block-production-lottery} to decide if a block producer is the
  winner of a specific slot. $\tau$ is set to result of call into
  {\code*{BabeApi\_slot\_winning\_threshold}} runtime entry.
\end{definition}

A block producer aiming to produce a block during $\mathcal{E}_n$ should run
Algorithm \ref{algo-block-production-lottery} to identify the slots it is
awarded. These are the slots during which the block producer is allowed to
build a block. The $\tmop{sk}$ is the block producer lottery secret key and
$n$ is the index of epoch for whose slots the block producer is running the
lottery.

\custombinding{5}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  5. }
  \label{algo-block-production-lottery}{\tmname{Block-production-lottery}}$(\tmop{sk}^{},
  n)$\\
  \hline
\end{tabular}

{\algorithmic{{\state{$r \leftarrow${\tmname{Epoch-Randomness$(n)$}}}}

{\state{{\FORTO{$i \assign 1$}{$\tmop{sc}_n$}}}}

{\state{$(d, \pi) \leftarrow${\tmem{{\tmname{VRF}}}}($r, i, \tmop{sk}$)}}

{\state{$A [i] \leftarrow (d, \pi)${\END}}}

{\state{{\RETURN{A}}}}}}

\hrulefill{\medskip}

For any slot $i$ in epoch $n$ where $d < \tau$, the block producer is required
to produce a block. For the definitions of {\tmname{Epoch-Randomness}} and
{\tmem{{\tmname{VRF}}}} functions, see Algorithm \ref{algo-epoch-randomness}
and Section \ref{sect-vrf} respectively.

\subsubsection{Slot number calculation}

It is essential for a block producer to calculate and validate the slot number
at a certain point in time. Slots are dividing the time continuum in an
overlapping interval. At a given time, the block producer should be able to
determine the set of slots which can be associated to a valid block generated
at that time. We formalize the notion of validity in the following
definitions:

\begin{definition}
  \label{slot-time-cal-tail}The {\tmstrong{slot tail}}, formally referred to
  by $\tmop{SlTl}$ represents the number of on-chain blocks that are used to
  estimate the slot time of a given slot. This number is set to be 1200.
\end{definition}

Algorithm \ref{algo-slot-time} determines the slot time for a future slot
based on the {\tmem{block arrival time}} associated with blocks in the slot
tail defined in Definition \ref{defn-block-time}.

\begin{definition}
  \label{defn-block-time}The {\tmstrong{block arrival time}} of block $B$ for
  node $j$ formally represented by {\tmstrong{$T^j_B$}} is the local time of
  node $j$ when node $j$ has received the block $B$ for the first time. If the
  node $j$ itself is the producer of $B$, $T_B^j$ is set equal to the time
  that the block is produced. The index $j$ in $T^j_B$ notation may be dropped
  when there is no ambiguity about the underlying node.
\end{definition}

In addition to the arrival time of block $B$, the block producer also needs to
know how many slots have passed since the arrival of $B$. This value is
formalized in Definition \ref{defn-slot-offset}.

\begin{definition}
  \label{defn-slot-offset}Let $s_i$ and $s_j$ be two slots belonging to epochs
  $\mathcal{E}_k$ and $\mathcal{E}_l$. By {\tmname{Slot-Offset}}$(s_i, s_j)$
  we refer to the function whose value is equal to the number of slots between
  $s_i$ and $s_j$ (counting $s_j$) on time continuum. As such, we have
  {\tmname{Slot-Offset}}$(s_i, s_i) = 0$.
\end{definition}

\custombinding{6}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  6. } \label{algo-slot-time}{\tmname{Slot-Time}}($s$:
  the number of the slots whose time needs to be determined)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$T_s \leftarrow \{ \}$}}

{\state{$B_d \leftarrow${\tmname{Deepest-Leaf($\tmop{BT}$)}}}}

{\state{{\FORIN{$B_i$}{{\tmname{SubChain}}($B_{H_n (B_d) - \tmop{SITL}}$,
$B_d$)}}}}

{\state{{\tmname{$s_t^{B_i} \leftarrow T^{}_{B_i}$+Slot-Offset($s_{B_i},
s$)$\times \mathcal{T}_{}$}}}}

{\state{$T_s \leftarrow T_s \cup s_t^{B_i}${\END}}}

{\state{{\RETURN{Median($T_s$)}}}}}}

\hrulefill{\medskip}

\subsubsection{Block Production}

At each epoch, each block producer should run Algorithm
\ref{algo-block-production} to produce blocks during the slots it has been
awarded during that epoch. The produced blocks need to be broadcasted
alongside with the {\tmem{babe header}} defined in Definition
\ref{defn-babe-header}.

\begin{definition}
  The \label{defn-babe-header}{\tmstrong{Babe Header}} of block B, referred to
  formally by {\tmstrong{$H_{\tmop{Babe}} (B)$}} is a tuple that consists of
  the following components:
  \[ (\pi, S_B, \tmop{pk}, s, d) \]
  in which:
  
  \begin{center}
    \begin{tabular}{rl}
      s: & is the slot at which the block is produced.\\
      $\pi, d$: & are the results of the block lottery for slot s. \\
      $\tmop{pk}_j^s$: & is the SR25519 session public key associated with the
      block producer. \\
      $S_B$: & $\tmop{Sig}_{\tmop{SR} 25519, \tmop{sk}^s_j}
      (\tmop{Enc}_{\tmop{SC}} (s, \tmop{Black} 2 s (\tmop{Head} (B_{}),
      \pi)))$
    \end{tabular}
  \end{center}
  
  \ 
\end{definition}

\custombinding{7}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  7. }
  \label{algo-block-production}{\tmname{Invoke-Block-Authoring}}($\tmop{sk}$,
  pk, $n$, $\tmop{BT} : \tmop{Current} \tmop{Block} \tmop{Tree}$)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$A
\leftarrow${\tmname{Block-production-lottery($\tmop{sk}$, $n$)}}}}

{\state{{\FORTO{$s \leftarrow 1$}{$\tmop{sc}_n$}}}}

{\state{{\tmname{Wait}}({\tmstrong{until}} {\tmname{Slot-Time}}(s))}}

{\state{$(d, \pi) \leftarrow A [s]$}}

{\state{{\IF{$d < \tau$}}}}

{\state{$C_{\tmop{Best}} \leftarrow${\tmname{Longest-Branch}}(BT)}}

{\state{{\tmname{$B_s \leftarrow$Build-Block($C_{\tmop{Best}}$)}}}}

{\state{{\tmname{Broadcast-Block}}($B_s, H_{\tmop{Babe}} (B_s)$)}}}}

\hrulefill{\medskip}

\subsubsection{Block Validation}

\subsubsection{Epoch Randomness}

At the end of epoch $\mathcal{E}_n$, each block producer is able to compute
the randomness seed it needs in order to participate in the block production
lottery in epoch $\mathcal{E}_{n + 2}$. The computation of the seed is
described in Algorithm \ref{algo-epoch-randomness} which uses the concept of
epoch subchain described in Definition \ref{defn-epoch-subchain}.

\custombinding{8}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  8. }
  \label{algo-epoch-randomness}{\tmname{Epoch-Randomness}}($n > 2 :$epoch
  index)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$\rho \leftarrow \phi$}}

{\state{{\FORIN{$B$}{}}{\tmem{{\tmname{SubChain($\mathcal{E}_{n - 2}$)}}}}}}

{\state{$\rho \leftarrow \rho | | d_B${\END}}}

{\state{{\RETURN{Blake2s({\tmname{Epoch-Randomness}}($n -
1$)\textbar\textbar$n$\textbar\textbar$\rho$)}}}}}}

\hrulefill{\medskip}

In which value $d_B$ is the VRF output computed for slot $s_B$ by running
Algorithm \ref{algo-block-production-lottery}.

\subsection{Finality}\label{sect-finality}

Polkadot RE uses GRANDPA Finality protocol
{\cite{alistair_stewart_grandpa:_2019}} to finalize blocks. Finality is
obtained by consecutive rounds of voting by validator nodes. Validators
execute GRANDPA finality process in parallel to Block Production as an
independent service. In this section, we describe the different functions that
GRANDPA service is supposed to perform to successfully participate in the
block finalization process.

\subsubsection{Preliminaries}

\begin{definition}
  A {\tmstrong{GRANDPA Voter}}, $v$, is represented by a key pair
  $(k^{\tmop{pr}}_v, v_{\tmop{id}})$ where $k_v^{\tmop{pr}}$ represents its
  private key which is an $\tmop{ED} 25519$ private key, is a node running
  GRANDPA protocol, and broadcasts votes to finalize blocks in a Polkadot RE -
  based chain. The {\tmstrong{set of all GRANDPA voters}} is indicated by
  $\mathbb{V}$. For a given block B, we have4
  \[ \mathbb{V}_B = \tmverbatim{\tmop{authorities}} (B) \]
  where $\mathtt{authorities}$ is the entry into runtime described in Section
  \ref{sect-runtime-api-auth}.
\end{definition}

\begin{definition}
  {\tmstrong{GRANDPA state}}, $\tmop{GS}$, is defined as
  \[ \tmop{GS} \assign \{\mathbb{V}, \tmop{id}_{\mathbb{V}}, r\} \]
  where:
  
  $\mathbb{V}$: is the set of voters.
  
  {\tmstrong{$\mathbb{V}_{\tmop{id}}$}}: is an incremental counter tracking
  \tmverbatim{}membership, which changes in V.
  
  {\tmstrong{r}}: is the votin\tmverbatim{}g round number.
\end{definition}

Now we need to define how Polkadot RE counts the number of votes for block
$B$. First a vote is defined as:

\begin{definition}
  \label{def-vote}A {\tmstrong{GRANDPA vote }}or simply a vote for block $B$
  is an ordered pair defined as
  \[ V_{\nosymbol} (B) \assign (H_h (B), H_i (B)) \]
  where $H_h (B)$ and $H_i (B)$ are the block hash and the block number
  defined in Definitions \ref{def-block-header} and
  \ref{def-block-header-hash} respectively.
\end{definition}

\begin{definition}
  Voters engage in a maximum of two sub-rounds of voting for each round $r$.
  The first sub-round is called {\tmstrong{pre-vote}} and\tmverbatim{} the
  second sub-round is called {\tmstrong{pre-commit}}.
  
  By {\tmstrong{$V_v^{r, \tmop{pv}}$}} and {\tmstrong{$V_v^{r, \tmop{pc}}$}}
  we refer to the vote cast by voter $v$ in round $r$ (for block $B$) during
  the pre-vote and the pre-commit sub-round respectively.
\end{definition}

The GRANDPA protocol dictates how an honest voter should vote in each
sub-round, which is described in Algorithm \ref{alg-grandpa-round}. After
defining what constitues a vote in GRANDPA, we define how GRANDPA counts
votes.

\begin{definition}
  Voter $v$ {\tmstrong{equivocates}} if they broadcast two or more valid votes
  to blocks not residing on the same branch of the block tree during one
  voting sub-round. In such a situation, we say that $v$ is an
  {\tmstrong{equivocator}} and any vote $V_v^{r, \tmop{stage}} (B)$ cast by
  $v$ in that round is an {\tmstrong{equivocatory vote}} and
  \[ \mathcal{E}^{r, \tmop{stage}} \]
  represents the set of all equivocators voters in sub-round
  ``$\tmop{stage}$'' of round $r$. When we want to refer to the number
  of\tmverbatim{} equivocators whose equivocation has been observed by voter
  $v$ we refer to it by:
  \[ \mathcal{E}^{r, \tmop{stage}}_{\tmop{obs} (v)} \]
  
\end{definition}

\begin{definition}
  A vote $V_v^{r, \tmop{stage}} = V (B)$ is {\tmstrong{invalid}} if
  \begin{itemize}
    \begin{itemizedot}
      \item $H (B)$ does not correspond to a valid block;
      
      \item $B$ is not an (eventual) descendant of a previously finalized
      block;
      
      \item $M^{r, \tmop{stage}}_v$ does not bear a valid signature;
      
      \item $\tmop{id}_{\mathbb{V}}$ does not match the current $\mathbb{V}$;
      
      \item If $V_v^{r, \tmop{stage}}$ is an equivocatory vote.
    \end{itemizedot}
  \end{itemize}
\end{definition}

\begin{definition}
  For validator v, {\tmstrong{the set of observed direct votes for Block $B$
  in round $r$}}, formally denoted by $\tmop{VD}^{r, \tmop{stage}}_{\tmop{obs}
  (v)}^{\nosymbol}_{\nosymbol} (B)$ is equal to the union of:
  \begin{itemizedot}
    \item set of valid votes $V^{r, \tmop{stage}}_{v_i}$ cast in round $r$ and
    received by v such that $V^{r, \tmop{stage}}_{v_i} = V (B)$.
  \end{itemizedot}
\end{definition}

\begin{definition}
  We refer to {\tmstrong{the set of total votes observed by voter $v$ in
  sub-round ``$\tmop{stage}$'' of round $r$}} by {\tmstrong{$V^{r,
  \tmop{stage}}_{\tmop{obs} (v)}^{\nosymbol}_{\nosymbol}$}}.
  
  The {\tmstrong{set of all observed votes by $v$ in the sub-round stage of
  round $r$ for block $B$}}, {\tmstrong{$V^{r, \tmop{stage}}_{\tmop{obs} (v)}
  (B)$}} is equal to all of the observed direct votes casted for block $B$ and
  all of the $B$'s descendents defined formally as:
  \[ V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) \assign \bigcup_{v_i \in
     \mathbb{V}, B \geqslant B'} \tmop{VD}^{r, \tmop{stage}}_{\tmop{obs} (v)}
     (B')_{\nosymbol}^{\nosymbol}_{\nosymbol} \]
  The {\tmstrong{total number of observed votes for Block $B$ in round $r$}}
  is defined to be the size of that set plus the total number of equivocators
  voters:
  \[ \#V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) = |V^{r,
     \tmop{stage}}_{\tmop{obs} (v)} (B) | + | \mathcal{E}^{r,
     \tmop{stage}}_{\tmop{obs} (v)} | \]
\end{definition}

\begin{definition}
  The current {\tmstrong{pre-voted}} block $B^{r, \tmop{pv}}_v$ is the block
  with
  \[ H_n (B^{r, \tmop{pv}}_v) = \tmop{Max} (H_n (B) | \forall B :
     \#V_{\tmop{obs} (v)}^{r, \tmop{pv}} (B) \geqslant 2 / 3|\mathbb{V}|) \]
\end{definition}

Note that for genesis block $\tmop{Genesis}$ we always have $\#V_{\tmop{obs}
(v)}^{r, \tmop{pv}} (B) = | \mathbb{V} |$.

\

Finally, we define when a voter $v$ see a round as completable, that is when
they are confident that $B_v^{r, \tmop{pv}}$ is an upper bound for what is
going to be finalised in this round. \

\begin{definition}
  \label{defn-grandpa-completable}We say that round $r$ is
  {\tmstrong{completable}} if $|V^{r, \tmop{pc}}_{\tmop{obs} (v)} |
  +\mathcal{E}^{r, \tmop{pc}}_{\tmop{obs} (v)} > \frac{2}{3} \mathbb{V}$ and
  for all $B' > B_v^{r, \tmop{pv}}$:
  \[ \begin{array}{l}
       |V^{r, \tmop{pc}}_{\tmop{obs} (v)} | -\mathcal{E}^{r,
       \tmop{pc}}_{\tmop{obs} (v)} - |V^{r, \tmop{pc}}_{\tmop{obs}
       (v)_{\nosymbol}} (B') | > \frac{2}{3} |\mathbb{V}|
     \end{array} \]
\end{definition}

Note that in practice we only need to check the inequality for those $B' >
B_v^{r, \tmop{pv}}$ where $|V^{r, \tmop{pc}}_{\tmop{obs} (v)_{\nosymbol}} (B')
| > 0$.

\

\subsubsection{Voting Messages Specification}

Voting is done by means of broadcasting voting messages to the network.
Validators inform their peers about the block finalized in round $r$ by
broadcasting a finalization message (see Algorithm \ref{alg-grandpa-round} for
more details). These messages are specified in this section.

\begin{definition}
  A vote casted by voter $v$ should be broadcasted as a {\tmstrong{message
  $M^{r, \tmop{stage}}_v$}} to the network by voter $v$ with the following
  structure:
  \[ M^{r, \tmop{stage}}_v \assign \tmop{Enc}_{\tmop{SC}} (r,
     \tmop{id}_{\mathbb{V}}, \tmop{Enc}_{\tmop{SC}} (\tmop{stage}, V_v^{r,
     \tmop{stage}}, \tmop{Sig}_{\tmop{ED} 25519} (\tmop{Enc}_{\tmop{SC}}
     (\tmop{stage}, V_v^{r, \tmop{stage}}, r, V_{\tmop{id}}), v_{\tmop{id}})
  \]
  Where:
  \begin{center}
    \begin{tabular}{rll}
      r: & round number & 64 bit integer\\
      $V_{\tmop{id}}$: & incremental change tracker counter & 64 bit integer\\
      {\rightaligned{$v_{\tmop{id}}$}}: & Ed25519 public key of $v$ & 4 byte
      array\\
      {\rightaligned{}}$\tmop{stage}$: & 0 if it is the pre-vote sub-round & 1
      byte\\
      & 1 if it the pre-commit sub-round & 
    \end{tabular}
  \end{center}
  
\end{definition}

\begin{definition}
  \label{def-grandpa-justification}The {\tmstrong{justification for block B in
  round $r$}} of GRANDPA protocol defined $J^r (B)$ is a vector of pairs of
  the type:
  \[ (V (B'), (\tmop{Sign}^{r, \tmop{pc}}_{v_i} (B'), v_{\tmop{id}})) \]
  in which either
  \[ B' > B \]
  or $V^{r, \tmop{pc}}_{v_i} (B')$ is an equivocatory vote.
  
  In all cases, $\tmop{Sign}^{r, \tmop{pc}}_{v_i} (B')$ is the signature of
  voter $v_i$ broadcasted during the pre-commit sub-round of round r.
\end{definition}

\begin{definition}
  {\tmstrong{$\tmop{GRANDPA}$ finalizing message for block $B$ in round $r$}}
  represented as {\tmstrong{$M_v^{r, \tmop{Fin}}$(B)}} is a message
  broadcasted by voter $v$ to the network indicating that voter $v$ has
  finalized block $B$ in round $r$. It has the following structure:
  \[ M^{r, \tmop{Fin}}_v (B) \assign \tmop{Enc}_{\tmop{SC}} (r, V (B), J^r
     (B)) \]
  in which $J^r (B)$ in the justification defined in Definition
  \ref{def-grandpa-justification}.
\end{definition}

\subsubsection{Initiating the GRANDPA State}

A validator needs to initiate its state and sync it with other validators, to
be able to participate coherently in the voting process. In particular,
considering that voting is happening in different rounds and each round of
voting is assigned a unique sequential round number $r_v$, it needs to
determine and set its round counter $r$ in accordance with the current voting
round $r_n$, which is currently undergoing in the network.

As instructed in Algorithm \ref{alg-join-leave-grandpa}, whenever the
membership of GRANDPA voters changes, $r$ is set to 0 and $V_{\tmop{id}}$
needs to be incremented.

\custombinding{9}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  9. }
  \label{alg-join-leave-grandpa}{\tmname{Join-Leave-Grandpa-Voters}}
  ($\mathcal{V}$)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$r \leftarrow 0$}}

{\state{$\mathcal{V}_{\tmop{id}} \leftarrow \tmop{ReadState} ('
\tmop{AUTHORITY} \_ \tmop{SET} \_ \tmop{KEY}')$}}

{\state{$\mathcal{V}_{\tmop{id}} \leftarrow \mathcal{V}_{\tmop{id}} + 1$}}

{\state{{\tmname{Execute-One-Grandpa-Round}}$(r)$}}}}

\hrulefill{\medskip}

\subsubsection{Voting Process in Round $r$}

For each round $r$, an honest voter $v$ must participate in the voting process
by following Algorithm \ref{alg-grandpa-round}.

\custombinding{10}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  10. }
  \label{alg-grandpa-round}{\tmname{Play-Grandpa-round}}$(r)$\\
  \hline
\end{tabular}

{\algorithmic{{\state{$t_{r, v} \leftarrow$Time}}

{\state{$\tmop{primary} \leftarrow${\tmname{Derive-Primary}}}}

{\state{{\IF{$v = \tmop{primary}$}}}}

{\state{{\tmname{Broadcast(}}\left.$M_{v_{\nosymbol}}^{r - 1,
\tmop{Fin}}$({\tmname{Best-Final-Candidate}}($r$-1))\right){\END}}}

{\state{{\tmname{Receive-Messages}}({\tmstrong{until}} Time $\geqslant t_{r_,
v} + 2 \times T$ {\tmstrong{or}} $r$ {\tmstrong{is}} completable){\END}}}

{\state{$L \leftarrow${\tmname{Best-Final-Candidate}}($r$-1)}}

{\state{{\IF{{\tmname{Received($M_{v_{\tmop{primary}}}^{r, \tmop{pv}} (B)$)}}
{\tmstrong{and}} $B^{r, \tmop{pv}}_v \geqslant B > L$}}}}

{\state{$N \leftarrow B${\END}}}

{\state{{\ELSE{\ }}}}

{\state{$N \leftarrow B' : H_n (B') = \max \{H_n (B') : B' > L\} \END$}}

{\state{{\tmname{Broadcast}}($M_v^{r, \tmop{pv}} (N)$)}}

{\state{{\tmname{Receive-Messages}}({\tmstrong{until}} $B^{r,
\tmop{pv}_{\nosymbol}}_v \geqslant L$ {\tmstrong{and}} (Time $\geqslant t_{r_,
v} + 4 \times T${\tmstrong{ or }}$r$ {\tmstrong{is}} completable))}}

{\state{{\tmname{Broadcast($M_v^{r, \tmop{pc}}$($B_v^{r, \tmop{pv}}$))}}}}

{\state{{\tmname{Play-Grandpa-round}}($r + 1$)}}}}

\hrulefill{\medskip}

The condition of {\tmem{completablitiy}} is defined in Definition
\ref{defn-grandpa-completable}. {\tmname{Best-Final-Candidate}} function is
explained in Algorithm \ref{algo-grandpa-best-candidate}.

\custombinding{11}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  11. }
  \label{algo-grandpa-best-candidate}{\tmname{Best-Final-Candidate}}($r$)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$\mathcal{C}_{\nosymbol} \leftarrow \{B' |B' \leqslant
B_v^{r, \tmop{pv}} : |V_v^{r, \tmop{pc}} | -\#V_v^{r, \tmop{pc}} (B')
\leqslant 1 / 3|\mathbb{V}|\}$}}

{\state{{\IF{$\mathcal{C}= \phi$}}}}

{\state{{\RETURN{$\phi${\END}}}}}

{\state{{\ELSE{\ }}}}

{\state{{\RETURN{$E \in \mathcal{C}: H_n (E) = \max \{H_n (B') : B' \in
\mathcal{C}\}${\END}}}}}}}

\hrulefill{\medskip}

\custombinding{12}{\noindent}\begin{tabular}{l}
  \hline
  \tmtextbf{Algorithm  12. } {\tmname{Attempt-To-Finalize-Round}}($r$)\\
  \hline
\end{tabular}

{\algorithmic{{\state{$L \leftarrow${\tmname{Last-Finalized-Block}}}}

{\state{$E \leftarrow${\tmname{Best-Final-Candidate}}($r$)}}

{\state{{\IF{$E \geqslant L$ {\tmstrong{and}} $V^{r - 1,
\tmop{pc}}_{\tmop{obs} (v)}^{\nosymbol}_{\nosymbol} (E) > 2 / 3
|\mathcal{V}|$}}}}

{\state{{\tmname{Last-Finalized-Block}}$\leftarrow B^{r, \tmop{pc}}$}}

{\state{{\IF{$M_v^{r, \tmop{Fin}} (E) \nin${\tmname{Received-Messages}}}}}}

{\state{{\tmname{Broadcast}}($M_v^{r, \tmop{Fin}} (E)$)}}

{\state{{\RETURN{{\END}{\END}}}}}

{\state{{\tmstrong{schedule-call}} {\tmname{Attempt-To-Finalize-Round}}($r$)
{\tmstrong{when}} {\tmname{Receive-Messages}} }}}}

\hrulefill{\medskip}

\section{Cryptographic Algorithms}

\subsection{Hash functions}\label{sect-hash-functions}

\subsection{Randomness}\label{sect-randomness}

\subsection{VRF}\label{sect-vrf}

\section{Auxiliary Encodings}\label{sect-encoding}

\

\subsection{SCALE Codec}\label{sect-scale-codec}

Polkadot RE uses {\tmem{Simple Concatenated Aggregate Little-Endian'' (SCALE)
codec}} to encode byte arrays as well as other data structures. SCALE provides
a canonical encoding to produce consistent hash values across their
implementation, including the Merkle hash proof for the State Storage.

\begin{definition}
  \label{def-scale-byte-array}The {\tmstrong{SCALE codec}} for {\tmstrong{Byte
  array}} $A$ such that
  \[ A \assign b_1 b_2 \ldots b_n \]
  such that $n < 2^{536}$ is a byte array refered to $\tmop{Enc}_{\tmop{SC}}
  (A)$ and defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (A) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| A \|) | | A \]
  where $\tmop{Enc}_{\tmop{SC}}^{\tmop{Len}}$ is defined in Definition
  \ref{defn-sc-len-encoding}. 
\end{definition}

\begin{definition}
  \label{defn-scale-tuple}The {\tmstrong{SCALE codec}} for {\tmstrong{Tuple}}
  $T$ such that:
  \[ T \assign (A_1, \ldots, A_n) \]
  Where $A_i$'s are values of {\tmstrong{different types}}, is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (T) \assign \tmop{Enc}_{\tmop{SC}} (A_1) |
     \tmop{Enc}_{\tmop{SC}} (A_2) | \ldots | \tmop{Enc}_{\tmop{SC}} (A_n) \]
\end{definition}

In case of a tuple (or struct), the knowledge of the shape of data is not
encoded even though it is necessary for decoding. The decoder needs to derive
that information from the context where the encoding/decoding is happenning.

\begin{definition}
  \label{defn-scale-list}The {\tmstrong{SCALE codec}} for
  {\tmstrong{sequence}} $S$ such that:
  \[ S \assign A_1, \ldots, A_n \]
  where $A_i$'s are values of {\tmstrong{the same type}} (and the decoder is
  unable to infer value of $n$ from the context) is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (T) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| S \|) \tmop{Enc}_{\tmop{SC}} (A_1) | \tmop{Enc}_{\tmop{SC}} (A_2) |
     \ldots | \tmop{Enc}_{\tmop{SC}} (A_n) \]
  where $\tmop{Enc}_{\tmop{SC}}^{\tmop{Len}}$ is defined in Definition
  \ref{defn-sc-len-encoding}.
\end{definition}

\begin{definition}
  The {\tmstrong{SCALE codec}} for {\tmstrong{boolean value}} $b$ defined as a
  byte as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}_{\tmop{SC}} : & \{ \tmop{False}, \tmop{True} \} \rightarrow
       \mathbb{B}_1\\
       & b \rightarrow \left\{ \begin{array}{lcl}
         0 &  & b = \tmop{False}\\
         1 &  & b = \tmop{True}
       \end{array} \right.
     \end{array} \]
\end{definition}

\begin{definition}
  The {\tmstrong{SCALE codec, $\tmop{Enc}_{\tmop{SC}}$}} for other types such
  as fixed length integers not defined here otherwise, is equal to little
  endian encoding of those values defined in Definition
  \ref{defn-little-endian}. 
\end{definition}

\subsubsection{Length Encoding}\label{sect-int-encoding}

{\tmem{SCALE Length encoding}} is used to encode integer numbers of variying
sizes prominently in an encoding length of arrays:

\begin{definition}
  \label{defn-sc-len-encoding}{\tmstrong{SCALE Length Encoding,
  $\tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}$}} also known as compact encoding of a
  non-negative integer number $n$ is defined as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}} : & \mathbb{N} \rightarrow
       \mathbb{B}\\
       & n \rightarrow b \assign \left\{ \begin{array}{lll}
         l^{\nosymbol}_1 &  & 0 \leqslant n < 2^6\\
         i^{\nosymbol}_1 i^{\nosymbol}_2 &  & 2^6 \leqslant n < 2^{14}\\
         j^{\nosymbol}_1 j^{\nosymbol}_2 j_3 &  & 2^{14} \leqslant n <
         2^{30}\\
         k_1^{\nosymbol} k_2^{\nosymbol} \ldots k_m^{\nosymbol}  &  & 2^{30}
         \leqslant n
       \end{array} \right.
     \end{array} \]
  in where the bits of byte array b are defined as follows:
  \[ \begin{array}{lcc}
       l^1_1 l_1^0 & = & 00\\
       i^1_1 i_1^0 & = & 01\\
       j^1_1 j_1^0 & = & 10\\
       k^1_1 k_1^0 & = & 11
     \end{array} \]
  and the rest of the bits of $b$ store the value of $n$ in little-endian
  format in base-2 as follows:
  \[ \left. \begin{array}{lll}
       l^7_1 \ldots l^3_1 l^2_1 &  & n < 2^6\\
       i_2^7 \ldots i_2^0 i_1^7 \ldots i^2_1^{\nosymbol} &  & 2^6 \leqslant n
       < 2^{14}\\
       j_4^7 \ldots j_4^0 j_3^7 \ldots j_1^7 \ldots j^2_1 &  & 2^{14}
       \leqslant n < 2^{30}\\
       k_2 + k_3 2^8 + k_4 2^{2 \cdummy 8} + \cdots + k_m 2^{(m - 2) 8} &  &
       2^{30} \leqslant n
     \end{array} \right\} \assign n \]
  such that:
  \[ k^7_1 \ldots k^3_1 k^2_1 : = m - 4 \]
\end{definition}

\subsection{Hex Encoding}

Practically, it is more convenient and efficient to store and process data
which is stored in a byte array. On the other hand, the Trie keys are broken
into 4-bits nibbles. Accordingly, we need a method to encode sequences of
4-bits nibbles into byte arrays canonically:

\begin{definition}
  \label{defn-hex-encoding}Suppose that $\tmop{PK} = (k_1, \ldots, k_n)$ is a
  sequence of nibbles, then
  
  \begin{tabular}{l}
    $\tmop{Enc}_{\tmop{HE}} (\tmop{PK}) \assign$\\
    $\left\{ \begin{array}{lll}
      \tmop{Nibbles}_4 & \rightarrow & \mathbb{B}\\
      \tmop{PK} = (k_1, \ldots, k_n) & \mapsto & \left\{ \begin{array}{l}
        \begin{array}{ll}
          (16 k_1 + k_2, \ldots, 16 k_{2 i - 1} + k_{2 i}) & n = 2 i\\
          (k_1, 16 k_2 + k_3, \ldots, 16 k_{2 i} + k_{2 i + 1}) & n = 2 i + 1
        \end{array}
      \end{array} \right.
    \end{array} \right.$
  \end{tabular}
\end{definition}

\section{Genesis Block Specification}\label{sect-genisis-block}

\section{Predefined Storage keys}\label{sect-predef-storage-keys}

\section{Runtime upgrade}\label{sect-runtime-upgrade}

\appendix\section{Runtime API\label{sect-runtime-api}}

Runtime API is a set of functions that Polkadot RE exposes to Runtime to
access external functions needed for various reasons, such as Storage of
content, access and manipulation, memory allocation, and also efficiency. The
functions are specified in each subsequent subsection for each category of
those functions.

\subsection{Storage}

\subsubsection{\tmverbatim{ext\_set\_storage}}

Sets the value of a specific key in the state storage.

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_storage
  (param $key_data i32) (param $key_len i32) (param $value_data i32)                           (param $value_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer indicating the buffer containing the key.
  
  \item \tmverbatim{key\_len}: the key length in bytes.
  
  \item \tmverbatim{value}: a pointer indicating the buffer containing the
  value to be stored under the key.
  
  \item \tmverbatim{value\_len}: \ the length of the value buffer in bytes.
\end{itemize}

\subsubsection{\tmverbatim{ext\_storage\_root}}

Retrieves the root of the state storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_storage_root
  (param $result_ptr i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result\_ptr}: a memory address pointing at a byte array
  which contains the root of the state storage after the function concludes.
\end{itemize}

\subsubsection{\tmverbatim{ext\_blake2\_256\_enumerated\_trie\_root}}

Given an array of byte arrays, arranges them in a Merkle trie, defined
in\tmverbatim{{\tmem{{\tmstrong{}}}}} Section \ref{sect-merkl-proof}, and
computes the trie root hash.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_blake2_256_enumerated_trie_root
      (param $values_data i32) (param $lens_data i32) (param $lens_len i32) 
      (param $result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{values\_data}: a memory address pointing at the buffer
  containing the array where byte arrays are stored consecutively.
  
  \item \tmverbatim{lens\_data}: an array of \tmverbatim{i32} elements each
  stores the length of each byte array stored in \tmverbatim{value\_data}.
  
  \item \tmverbatim{len}s\_len: the number of \tmverbatim{i32} elements in
  \tmverbatim{lens\_data}.
  
  \item \tmverbatim{result}: a memory address pointing at the beginning of a
  32-byte byte array containing the root of the Merkle trie corresponding to
  elements of \tmverbatim{values\_data}.
\end{itemize}

\subsubsection{\tmverbatim{ext\_clear\_prefix}}

Given a byte array, this function removes all storage entries whose key
matches the prefix specified in the array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_clear_prefix
      (param $prefix_data i32) (param $prefix_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{prefix\_data}: a memory address pointing at the buffer
  containing the byte array containing the prefix.
  
  \item \tmverbatim{prefix\_len}: the length of the byte array in number of
  bytes.
\end{itemize}

\subsubsection{\tmverbatim{}\tmverbatim{ext\_clear\_storage}}

Given a byte array, this function removes the storage entry whose key is
specified in the array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_clear_storage
      (param $key_data i32) (param $key_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
\end{itemize}

\subsubsection{\tmverbatim{ext\_exists\_storage}}

Given a byte array, this function checks if the storage entry corresponding to
the key specified in the array exists.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_exists_storage
      (param $key_data i32) (param $key_len i32) (result i32)
    )
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{result}: An \tmverbatim{i32} integer which is equal to 1
  verifies if an entry with the given key exists in the storage or 0 if the
  key storage does not contain an entry with the given key.
\end{itemize}

\subsubsection{\tmverbatim{ext\_get\_allocated\_storage}}

Given a byte array, this function allocates a large enough buffer in the
memory and retrieves the value stored under the key that is specified in the
array. Then, it stores it in the allocated buffer if the entry exists in the
storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $get_allocated_storage
      (param $key_data i32) (param $key_len i32) (param $written_out i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{written\_out}: the function stores the length of the
  retrieved value in number of bytes if the enty exists. If the entry does not
  exist, it returns $2^{32} - 1$.
  
  \item \tmverbatim{result}: A pointer to the buffer in which the function
  allocates and stores the value corresponding to the given key if such an
  entry exist; otherwise it is equal to 0.
\end{itemize}

\subsubsection{\tmverbatim{ext\_get\_storage\_into}}

Given a byte array, this function retrieves the value stored under the key
specified in the array and stores a specified chunk of it in the provided
buffer, if the entry exists in the storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_get_storage_into 
      (param $key_data i32) (param $key_len i32) (param $value_data i32)
      (param $value_len i32) (param $value_offset i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{value\_data}: a pointer to the buffer in which the
  function stores the chunk of the value it retrieves.
  
  \item \tmverbatim{value\_len}: the (maximum) length of the chunk in bytes
  the function will read of the value and will store in the
  \tmverbatim{value\_data} buffer.
  
  \item \tmverbatim{value\_offset}: the offset of the chunk where the function
  should start storing the value in the provided buffer, i.e. the number of
  bytes the functions should skip from the retrieved value before storing the
  data in the \tmverbatim{value\_data} in number of bytes.
  
  \item \tmverbatim{result}: The number of bytes the function writes in
  \tmverbatim{value\_data} if the value exists or $2^{32} - 1$ if the entry
  does not exist under the specified key.
\end{itemize}

\subsubsection{To be Specced}

\begin{itemize}
  \item \tmverbatim{ext\_clear\_child\_storage}
  
  \item \tmverbatim{ext\_exists\_child\_storage}
  
  \item \tmverbatim{ext\_get\_allocated\_child\_storage}
  
  \item \tmverbatim{ext\_get\_child\_storage\_into}
  
  \item \tmverbatim{ext\_kill\_child\_storage}
  
  \item \tmverbatim{ext\_set\_child\_storage}
  
  \item \tmverbatim{ext\_storage\_changes\_root}
\end{itemize}

\subsection{Memory}

\subsubsection{\tmverbatim{ext\_malloc}}

Allocates memory of a requested size in the heap.

\

{\tmstrong{Prototype}}:
\begin{alltt}
(func $ext_malloc
  (param $size i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{size:} the size of the buffer to be allocated in number of
  bytes. 
\end{itemize}


{\tmstrong{Result}}:
\begin{itemize}
  a memory address pointing at the beginning of the allocated buffer.
\end{itemize}

\subsubsection{\tmverbatim{ext\_free}}

Deallocates a previously allocated memory.

\

{\tmstrong{Prototype}}:
\begin{alltt}
(func $ext_free
      (param $addr i32))
\end{alltt}


{\tmstrong{Arguments:}}
\begin{itemize}
  \item \tmverbatim{addr}: a 32bit memory address pointing at the allocated
  memory.
\end{itemize}

\subsubsection{Input/Output}

\begin{itemize}
  \item \tmverbatim{ext\_print\_hex}
  
  \item \tmverbatim{ext\_print\_num}
  
  \item \tmverbatim{ext\_print\_utf8}
\end{itemize}

\subsection{Cryptograhpic auxiliary functions}

\subsubsection{\tmverbatim{ext\_blake2\_256}}

Computes the Blake2s hash of a given byte array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func (export "ext_blake2_256")
      (param $data i32) (param  $len i32) (param $out i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a memory address pointing at the buffer containing
  the byte array to be hashed.
  
  \item \tmverbatim{len}: the length of the byte array in bytes.
  
  \item \tmverbatim{out}: a memory address pointing at the beginning of a
  32-byte byte array contanining the Blake2s hash of the data.
\end{itemize}

\subsubsection{\tmverbatim{ext\_keccak\_256}}

Computes the Keccak-256 hash of a given byte array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_keccak_256
      (param $data i32) (param $len i32) (param $out i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a memory address pointing at the buffer containing
  the byte array to be hashed.
  
  \item \tmverbatim{len}: the length of the byte array in bytes.
  
  \item \tmverbatim{out}: a memory address pointing at the beginning of a
  32-byte byte array contanining the Keccak-256 hash of the data.
\end{itemize}

\subsubsection{\tmverbatim{ext\_twox\_128}}

Computes the {\tmem{xxHash64}} algorithm (see {\cite{collet_extremely_2019}})
twice initiated with seeds 0 and 1 and applied on a given byte array and
outputs the concatenated result.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_twox_128
       (param $data i32) (param $len i32) (param $out i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a memory address pointing at the buffer containing
  the byte array to be hashed.
  
  \item \tmverbatim{len}: the length of the byte array in bytes.
  
  \item \tmverbatim{out}: a memory address pointing at the beginning of a
  16-byte byte array containing \ {\tmem{$\text{xxhash}
  64_0$}}(\tmverbatim{data})\textbar\textbar{\tmem{$\text{xxhash64}_1$}}(\tmverbatim{data})
  where {\tmem{$\text{xxhash} 64_i$}} is the xxhash64 function initiated with
  seed $i$ as a 64bit unsigned integer.
\end{itemize}

\subsubsection{\tmverbatim{ext\_ed25519\_verify}}

Given a message signed by the ED25519 signature algorithm alongside with its
signature and the allegedly signer public key, it verifies the validity of the
signature by the provided public key.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_ed25519_verify
      (param $msg_data i32) (param $msg_len i32) (param $sig_data i32)
      (param $pubkey_data i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{msg\_data}: a pointer to the buffer containing the message
  body.
  
  \item \tmverbatim{msg\_len}: an \tmverbatim{i32} integer indicating the size
  of the message buffer in bytes.
  
  \item \tmverbatim{sig\_data}: a pointer to the 64 byte memory buffer
  containing the ED25519 signature corresponding to the message.
  
  \item \tmverbatim{pubkey\_data}: a pointer to the 32 byte buffer containing
  the public key and corresponding to the secret key which has signed the
  message.
  
  \item \tmverbatim{result}: \ an in\tmverbatim{}teger value equal to 0
  indicating the validity of the signature or a nonzero value otherwise.
\end{itemize}

\subsubsection{\tmverbatim{ext\_sr25519\_verify}}

Given a message signed by the SR25519 signature algorithm alongside with its
signature and the allegedly signer public key, it verifies the validity of the
signature by the provided public key.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_sr25519_verify
      (param $msg_data i32) (param $msg_len i32) (param $sig_data i32)
      (param $pubkey_data i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{msg\_data}: a pointer to the buffer containing the message
  body.
  
  \item \tmverbatim{msg\_len}: an \tmverbatim{i32} integer indicating the size
  of the message buffer in bytes.
  
  \item \tmverbatim{sig\_data}: a pointer to the 64 byte memory buffer
  containing the SR25519 signature corresponding to the message.
  
  \item \tmverbatim{pubkey\_data}: a pointer to the 32 byte buffer containing
  the public key and corresponding to the secret key which has signed the
  message.
  
  \item \tmverbatim{result}: \ an in\tmverbatim{}teger value equal to 0
  indicating the validity of the signature or a nonzero value otherwise.
\end{itemize}

\subsubsection{To be Specced}

\begin{itemize}
  \item \tmverbatim{ext\_twox\_256}
\end{itemize}

\subsection{Sandboxing}

\subsubsection{To be Specced}

\begin{itemize}
  \item \tmverbatim{ext\_sandbox\_instance\_teardown}
  
  \item \tmverbatim{ext\_sandbox\_instantiate}
  
  \item \tmverbatim{ext\_sandbox\_invoke}
  
  \item \tmverbatim{ext\_sandbox\_memory\_get}
  
  \item \tmverbatim{ext\_sandbox\_memory\_new}
  
  \item \tmverbatim{ext\_sandbox\_memory\_set}
  
  \item \tmverbatim{ext\_sandbox\_memory\_teardown}
\end{itemize}

\subsection{Auxillary Debugging API}

\subsubsection{\tmverbatim{ext\_print\_hex}}

Prints out the content of the given buffer on the host's debugging console.
Each byte is represented as a two-digit hexadecimal number.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_print_hex
      (param $data i32) (parm $len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer to the buffer containing the data that
  needs to be printed.
  
  \item \tmverbatim{len}: an \tmverbatim{i32} integer indicating the size of
  the buffer containing the data in bytes.
\end{itemize}

\subsubsection{\tmverbatim{ext\_print\_utf8}}

Prints out the content of the given buffer on the host's debugging console.
The buffer content is interpreted as a UTF-8 string if it represents a valid
UTF-8 string, otherwise does nothing and returns.

{\tmstrong{Prototype:}}o
\begin{alltt}
    (func $ext_print_utf8
      (param $utf8_data i32) (param $utf8_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{utf8\_data}: a pointer to the buffer containing the
  utf8-encoded string to be printed.
  
  \item \tmverbatim{utf8\_len}: an \tmverbatim{i32} integer indicating the
  size of the buffer containing the UTF-8 string in bytes.
\end{itemize}

\subsection{Misc}

\subsubsection{To be Specced}
\begin{itemizedot}
  \item \tmverbatim{ext\_chain\_id}
\end{itemizedot}
\tmverbatim{}\subsection{Not implemented in Polkadot-JS}

\begin{thebibliography}{DGKR18}
  \bibitem[Ali19]{alistair_stewart_grandpa:_2019}Alistair Stewart.
  {\newblock}GRANDPA: A Byzantine Finality Gadgets, 2019.
  
  \bibitem[Col19]{collet_extremely_2019}Yann Collet. {\newblock}Extremely fast
  non-cryptographic hash algorithm. {\newblock}Technical report, -,
  http://cyan4973.github.io/xxHash/, 2019.
  
  \bibitem[DGKR18]{david_ouroboros_2018}Bernardo David, Peter Ga{\v z}i,
  Aggelos Kiayias, and Alexander Russell. {\newblock}Ouroboros praos: An
  adaptively-secure, semi-synchronous proof-of-stake blockchain. {\newblock}In
  \tmtextit{Annual International Conference on the Theory and Applications of
  Cryptographic Techniques}, pages 66--98. Springer, 2018.
  
  \bibitem[Gro19]{w3f_research_group_blind_2019}W3F~Research Group.
  {\newblock}Blind Assignment for Blockchain Extension. {\newblock}Technical
  Specification, Web 3.0 Foundation,
  http://research.web3.foundation/en/latest/polkadot/BABE/Babe/, 2019.
\end{thebibliography}

\end{document}
