* High level grandpa

#+begin_src plantuml :file grandpa_high_level.png
participant "cli::cli.rs" as cli 
participant "cli::service.rs" as cli_service
participant "client::service::ServiceBuilder" as service_builder
participant "client::service::NetworkService" as network_service
participant "finality_granpa::lib.rs" as sr_gf
participant "finality_granpa::VoterWork" as sr_gf_voter_work
participant "finality_granpa::Envioronment" as sr_gf_env

autoactivate on

cli -> cli_service ++ : new_full_start
cli_service -> service_builder ** : new
return 
cli -> cli_service ++ : new_full
cli_service -> service_builder ++ : with_network_protocol
service_builder -> network_service ** : new
return
cli_service -> network_service ++ : spawn_essential_task
network_service -> sr_gf ++ : run_grandpa_voter 
sr_gf -> sr_gf_voter_work ** #005500 : new
sr_gf_voter_work -> sr_gf_env ** : new
sr_gf -> sr_gf_voter_work ++ : rebuild_voter
sr_gf_voter_work -> Voter ** : new (last completed round, last finalized block)
sr_gf_voter_work -> Voter ++ : poll
return
#+end_src

#+results:
[[file:grandpa_high_level.png]]

* grandpa voter
#+begin_src plantuml :file grandpa_voter.png
autoactivate off

Network -> Voter ++ : poll
  Voter -> Voter ++ : process_incoming
    loop for all messages in global queue
      note over Voter: Only possible message types are Commit and Catchup
      alt it is a Commit message
        Voter -> PastRounds ++ : import_commit
        return
        alt was the commit for a background round
          note over Voter: we are actively voting on this round
          Voter -> Voter ++ : process_commit_outcome(for good commit)
          return
        else the commit does not belong to any active background round
          note over Voter
            we are not actively voting on this round
            just validate the signature and accept the block as finalized.
          end note
          Voter -> Voter ++ : validate_commit
          return
          alt the commit message is valid
            alt the finalized block number > last finalized block number
              note over Voter: last finalized block ← the new finalized block
              Voter -> Enviornment ++ : finalize the new finalized block
            end
            Voter -> Voter ++ : process_commit_outcome(for good commit)
            return
  
           else the commit message is invalid
             Voter -> Voter ++ : process_commit_outcome(for bad commit)
             return
           end
        end
      else it is a Catchup message
        Voter -> Voter ++ : vaidate_catchup
        alt Good CatchUp 
           note over Voter: catchup_round ← the round the catchup belong to 
           Voter -> VotingRound ++ : make a completed round
           return completed round
           Voter -> VotingRound ++ : new round whose last round to be the completed round 
           return new round
           note over Voter: last_finalized_round ← completed round
           VotingRound -> Environment ++ : completed (completed round)
           return
           Voter -> Voter ++ : process_catchup_outcome(for good catchup)
           return
        else Bad Catchup
          Voter -> Voter ++ : process_catchup_outcome(for bad catchup)
          return
        end /' good/bad catchup '/
      end /' alt message type '/
    end 
  return
  Voter -> Voter ++ : prune_background_rounds
  return
  Voter -> Voter ++ : global_out.poll
  return
    Voter -> Voter ++ : process_best_round
      Voter -> VotingRound ++ : best_round.poll
        VotingRound -> VotingRound ++ : process_incoming
          loop for all received messages for this round
            VotingRound -> VotingRound ++ : handle_vote
              alt it is a prevote message
                VotingRound -> Votes ++ : import_prevote
                return
              else it is a precommit message
                VotingRound -> Votes ++ : import_precommit
                return
              else it is a primary propose        
                VotingRound -> Votes ++ : who is the primary voter?
                return : primary_id
                alt I am the primary voter
                  note over VotingRound
                   set primary block as the 
                   one proposed in the 
                   message
                  end note
                else I am not the primary
                 note over VotingRound: do nothing
                end  
              end /'message type'/
            return
          end /'message loop'/
        return /'process incoming'/

        alt if last_round_state is not empty
          note over VotingRound: we can participate in voting process

          VotingRound -> VotingRound ++ : primary_propose

            VotingRound -> RoundState : current_state?
            alt if this round state is "Start":
              RoundState -> VotingRound : Start
              alt if we are primary
                alt if last round estimate > last round finalized
                  VotingRound -> Network ++ : send(PrimaryPropose, last round estimate)
                  return
                  VotingRound -> RoundState ++ : set State to "Proposed"
                  return 
                end
              end
            else anything other state 
              RoundState -> VotingRound : Other states
              note over VotingRound: do nothing
            end
          return

          VotingRound -> VotingRound ++ : prevote
            VotingRound -> RoundState : current_state?
            alt state is "Start" or "Proposed"
              RoundState -> VotingRound : Start or Proposed
              VotingRound -> Votes  : completable?
              alt prevote timer is up or votes are completable
                Votes --> VotingRound  : completable

                VotingRound --> VotingRound ++ : construct_prevote
                  note over VotingRound: Panic! if last round does not have estimate

                  VotingRound --> VotingRound ++ : compute_anscestor_of_best_block
                    alt if we do not have primary_block
                      note over VotingRound : ancester ←  last_round_estimate 
                    else if we have a primary_block
                      note over VotingRound: Panic! if there is no last_round_prevote_ghost
                      alt if primary_block = last_round_prevote_ghost
                        note over VotingRound : ancester ←  primary_block
                      else if #primary_block >= #last_round_prevote_ghost
                        note over VotingRound : ancester ←  last_round_estimate
                      else if #primary_block < #last_round_prevote_ghost (migh not be a desecndent)
                        note over VotingRound
                          if the primary block is in the ancestry of 
                          prevote ghost we vote for the best chain 
                          containing "it?".
                        end note
                        alt last_round_estimitate < primary_block <= last_prevote_ghost 
                          note over VotingRound : ancester ← primary_block
                        else  primary_block ∉ subChain[last_round_estimitate, last_prevote_ghost]
                            note over VotingRound : ancester ← last_round_estimate
                        else last_round_estimitate is not an ancestor of last_prevote_ghost 
                          note over VotingRound : This only happens if there is a massive equivocation
                          note over VotingRound : ancester ← last_round_estimate
                        end /' primary < pg '/
                      end /' primary = pg '/ 
                    end /' no priamyr '/
                  return /' compute_anscestor_of_best_block '/

                  VotingRound -> Environment ++ : best block of best chain containing the anscestor 
                    note over VotingRound
                      best block is the greatest block on the longest
                      chain which can be finalized by current auth set 
                    end note
                  return best block /' best block of best chain '/
                return /' construct_prevote '/

                alt prevote got constructed
                  VotingRound --> Envioronment ++ : prevoted
                  return
                  VotingRound --> Votes ++ : set_prevoted_index
                  return
                  VotingRound --> Network ++ : send prevote message
                  return
                  VotingRound --> RoundState : set state to "Prevoted"
                else failed to construct prevote
                  VotingRound --> RoundState : set state to "None"
                  VotingRound --> VotingState : set state to "No"
                end
              end
            else anything other state
              RoundState --> VotingRound  : other states
                note over VotingRound: do nothing
            end
          return

          VotingRound -> VotingRound ++ : precommit
            VotingRound -> RoundState : current_state?

            alt state is "Prevoted"
              RoundState -> VotingRound : "Prevoted"
              VotingRound -> VotingRound ++ : get last round estimate
              return 
              note over VotingRound
                Panic! if last round does not have estimate
                This means we started this round before last
                round is completable
              end note

              VotingRound -> Votes ++ : get prevote_ghost
              return

              alt prevote_ghost > last round estimate
                VotingRound --> Votes  : completable?

                alt precommit timer is up or votes are completable
                  Votes --> VotingRound  : completable

                  VotingRound --> VotingRound ++ : construct_precommit
                    VotingRound -> Votes ++ : get prevote_ghost
                    return

                    alt prevote_ghost exsits
                       note over VotingRound : pre-commit candidate ← prevote_ghost
                    else prevote_ghost does not exsits
                      VotingRound -> Votes ++ : base
                      return VotingGraph base
                      note over VotingRound : pre-commit candidate ← base
                    end
                    
                  return pre-commit candidate /'construct pre-commit'/

                  VotingRound --> Envioronment ++ : precommited
                  return
                  VotingRound --> Votes ++ : set_precommited_index
                  return
                  VotingRound --> Network ++ : send precommit message
                  return

                  VotingRound --> RoundState : set state to "Precommited"
         
                else failed to construct precommit
                  note over VotingRound: do nothing
                end
              else prevote_ghost > last round estimate
                note over VotingRound: do nothing
              end
            else anything other state
              RoundState --> VotingRound  : other states
              note over VotingRound: do nothing
            end
          return /' precommit '/
   
        else last round state is null
          note over VotingRound
            we are just catching up
            do not participate in voting
          end note
        end

        VotingRound -> VotingRound : process_incoming
          note right
            processing our own 
            messages in case we 
            voted
          end note
        
        VotingRound --> Votes  : completable?
        alt completable
          Votes --> VotingRound  : completable
          alt is last round estimate finalized
            VotingRound --> Voter : Ready
            Voter -> VotingRound: precommited?
            alt current round is Ready and precommited
              Voter -> Voter ++ : compelete best round 
              return
              note over Voter: start next round
            else voter has not precommited
              note over Voter: do not start next round
            end
          else last round estimate is not finalized
            VotingRound --> Voter : Not Ready
            note over Voter: do not start next round
          end
        else votes are not completable
          VotingRound --> Voter : Note Ready
          note over Voter: do not start next round
        end
      return
  Voter --> Voter
Voter --> Network
#+end_src

#+results:
[[file:grandpa_voter.png]]

